---
import Layout from "../layouts/Layout.astro";
---

<Layout>
    <div id="project-container">
        <h1 id="project-name">Loading project...</h1>
        <p id="project-description"></p>
        
        <select id="time-range">
            <option value="10m">Last 10 minutes</option>
            <option value="30m" selected>Last 30 minutes</option>
            <option value="1h">Last 1 hour</option>
            <option value="6h">Last 6 hours</option>
            <option value="12h">Last 12 hours</option>
            <option value="24h">Last 24 hours</option>
        </select>
        <div id="group-emotionbar-container">
            <h3>Group Mood Over Time</h3>
            <div class="emotion-gradient-bar-wrapper">
                <div class="emotion-gradient-bar"></div>
                <div id="emotion-tooltip"></div>
            </div>
            <div id="group-emotionbar-key">
                <ul>
                    <li id="key-anger">Anger</li>
                    <li id="key-disgust">Disgust</li>
                    <li id="key-fear">Fear</li>
                    <li id="key-happiness">Happiness</li>
                    <li id="key-sadness">Sadness</li>
                    <li id="key-surprise">Surprise</li>
                    <li id="key-neutral">Neutral</li>
                    <li id="key-nodata">No Data</li>
                </ul>
            </div>
        </div>
        
        <p id="group-mood-summary">
            <strong>Group Mood Summary:</strong>
            <span id="group-mood-text">Loading...</span>
        </p>
        
        <h2>Members</h2>
        <div id="add-member-section">
            <input type="text" id="new-member-username" placeholder="Enter username to add" />
            <button id="add-member-button">Add Member</button>
            <p id="add-member-message" class="message"></p>
        </div>
        <div id="member-list">Loading members...</div>

        <div id="project-actions-bottom">
            <button id="delete-project-button" class="danger-button">Delete Project</button>
            <p id="delete-project-message" class="message"></p>
        </div>
    </div>
</Layout>

<script>
    import { chorusAPI } from "../lib/sdk.js";
    import { navigate } from "astro:transitions/client";
    
    const newNeutralColor = "rgb(173, 216, 230)";
    const noDataColor = "rgb(220, 220, 220)";
    
    const emotionColorMap = {
        anger: "rgb(239, 83, 80)",
        disgust: "rgb(102, 187, 106)",
        fear: "rgb(66, 165, 245)",
        happiness: "rgb(255, 213, 79)",
        happy: "rgb(255, 213, 79)",
        sadness: "rgb(126, 87, 194)",
        surprise: "rgb(255, 167, 38)",
        neutral: newNeutralColor,
        nodata: noDataColor,
    };
    
    function getColor(emotionKey: string): string {
        return (
        emotionColorMap[
        emotionKey.toLowerCase() as keyof typeof emotionColorMap
        ] || noDataColor
        );
    }
    
    function parseTimeRangeToSeconds(timeRangeString: string): number {
        const value = parseInt(timeRangeString.slice(0, -1));
        const unit = timeRangeString.slice(-1).toLowerCase();
        switch (unit) {
            case "m":
            return value * 60;
            case "h":
            return value * 60 * 60;
            default:
            return value;
        }
    }
    
    let currentDataTimeRangeEnd: number | null = null;
    let currentOwnerId: string | null = null; // Declare ownerId variable accessible to handlers
    
    function createEmotionGradient(
    emotionData: { time: number; emotion: string }[],
    dataDuration: number,
    ) {
        emotionData.sort((a, b) => a.time - b.time);
        
        if (emotionData.length === 0) {
            return `linear-gradient(to right, ${noDataColor}, ${noDataColor})`;
        }
        
        const stops: { time: number; color: string }[] = [];
        const maxTimeGapPercent = 15;
        const epsilon = 0.001;
        
        if (emotionData[0].time > 0) {
            if (emotionData[0].time > maxTimeGapPercent) {
                stops.push({ time: 0, color: noDataColor });
                stops.push({
                    time: Math.max(0, emotionData[0].time - epsilon),
                    color: noDataColor,
                });
            } else {
                stops.push({
                    time: 0,
                    color: getColor(emotionData[0].emotion),
                });
            }
        } else {
            stops.push({
                time: 0,
                color: getColor(emotionData[0].emotion),
            });
        }
        
        for (let i = 0; i < emotionData.length; i++) {
            const currentPoint = emotionData[i];
            const currentColor = getColor(currentPoint.emotion);
            
            const lastStopTime =
            stops.length > 0 ? stops[stops.length - 1].time : -1;
            if (currentPoint.time > lastStopTime) {
                stops.push({
                    time: currentPoint.time,
                    color: currentColor,
                });
            } else if (
            currentPoint.time === lastStopTime &&
            stops[stops.length - 1].color !== currentColor
            ) {
                stops[stops.length - 1].color = currentColor;
            }
            
            if (i + 1 < emotionData.length) {
                const nextPoint = emotionData[i + 1];
                const timeGap = nextPoint.time - currentPoint.time;
                
                if (timeGap > maxTimeGapPercent) {
                    const gapStartTime = Math.min(
                    100,
                    currentPoint.time + epsilon,
                    );
                    const gapEndTime = Math.max(
                    gapStartTime,
                    nextPoint.time - epsilon,
                    );
                    
                    if (gapStartTime > currentPoint.time) {
                        stops.push({
                            time: gapStartTime,
                            color: currentColor,
                        });
                    }
                    stops.push({ time: gapStartTime, color: noDataColor });
                    stops.push({ time: gapEndTime, color: noDataColor });
                }
            }
        }
        
        const lastPoint = emotionData[emotionData.length - 1];
        if (lastPoint.time < 100) {
            if (100 - lastPoint.time > maxTimeGapPercent) {
                const gapStartTime = Math.min(
                100,
                lastPoint.time + epsilon,
                );
                if (gapStartTime > lastPoint.time) {
                    stops.push({
                        time: gapStartTime,
                        color: getColor(lastPoint.emotion),
                    });
                }
                stops.push({ time: gapStartTime, color: noDataColor });
                stops.push({ time: 100, color: noDataColor });
            } else {
                stops.push({
                    time: 100,
                    color: getColor(lastPoint.emotion),
                });
            }
        }
        
        const finalStopStrings = [];
        stops.sort((a, b) => a.time - b.time);
        
        for (let i = 0; i < stops.length; i++) {
            const current = stops[i];
            const timePercent = Math.max(
            0,
            Math.min(100, current.time),
            ).toFixed(4);
            const stopStr = `${current.color} ${timePercent}%`;
            
            if (finalStopStrings.length > 0) {
                const prevStopStr =
                finalStopStrings[finalStopStrings.length - 1];
                const [, prevTimePercentStr] = prevStopStr.split(" ");
                
                if (`${timePercent}%` === prevTimePercentStr) {
                    finalStopStrings[finalStopStrings.length - 1] = stopStr;
                    continue;
                }
                if (stopStr === prevStopStr) {
                    continue;
                }
            }
            finalStopStrings.push(stopStr);
        }
        
        if (
        finalStopStrings.length === 0 ||
        !finalStopStrings[0].endsWith(" 0.0000%")
        ) {
            let firstColor = noDataColor;
            if (finalStopStrings.length > 0) {
                const [color, timeStr] = finalStopStrings[0].split(" ");
                if (parseFloat(timeStr) === 0) {
                    firstColor = color;
                }
            }
            finalStopStrings.unshift(`${firstColor} 0.0000%`);
        }
        if (
        finalStopStrings.length === 0 ||
        !finalStopStrings[finalStopStrings.length - 1].endsWith(
        " 100.0000%",
        )
        ) {
            let lastColor = noDataColor;
            if (finalStopStrings.length > 0) {
                const [color, timeStr] =
                finalStopStrings[finalStopStrings.length - 1].split(" ");
                if (parseFloat(timeStr) === 100) {
                    lastColor = color;
                } else {
                    lastColor = color;
                }
            }
            const [, lastTimeStr] =
            finalStopStrings[finalStopStrings.length - 1].split(" ");
            if (parseFloat(lastTimeStr) < 100) {
                finalStopStrings.push(`${lastColor} 100.0000%`);
            }
        }
        
        const uniqueFinalStops = finalStopStrings.filter(
        (stop, index, arr) => {
            if (index === 0) return true;
            return stop !== arr[index - 1];
        },
        );
        
        if (uniqueFinalStops.length < 2) {
            return `linear-gradient(to right, ${noDataColor}, ${noDataColor})`;
        }
        
        const gradientString = `linear-gradient(to right, ${uniqueFinalStops.join(
        ", ",
        )})`;
        return gradientString;
    }
    
    async function loadTimeDependentData(
    projectId: string,
    timeRangeStart: number,
    timeRangeEnd: number,
    ) {
        const groupEmotionBarElement = document.querySelector(
        "#group-emotionbar-container .emotion-gradient-bar",
        ) as HTMLElement;
        
        if (groupEmotionBarElement) {
            groupEmotionBarElement.style.backgroundImage = `linear-gradient(to right, ${noDataColor}, ${noDataColor})`;
            groupEmotionBarElement.removeAttribute("data-min-ts");
            groupEmotionBarElement.removeAttribute("data-duration");
        }
        
        try {
            const result = await chorusAPI.getProjectAverageEmotions(
            projectId,
            timeRangeStart,
            timeRangeEnd,
            );
            
            const emotionData: { time: number; emotion: string }[] = [];
            let dataDuration = 0;
            let minDataTimestamp = Infinity;
            let maxDataTimestamp = -Infinity;
            
            if (result && result.length > 0) {
                const validTimestamps: number[] = [];
                result.forEach((average) => {
                    const ts = Date.parse(average.interval) / 1000;
                    if (!isNaN(ts)) {
                        validTimestamps.push(ts);
                        minDataTimestamp = Math.min(minDataTimestamp, ts);
                        maxDataTimestamp = Math.max(maxDataTimestamp, ts);
                    }
                });
                
                if (validTimestamps.length > 0) {
                    dataDuration = maxDataTimestamp - minDataTimestamp;
                    
                    if (groupEmotionBarElement) {
                        groupEmotionBarElement.setAttribute(
                        "data-min-ts",
                        minDataTimestamp.toString(),
                        );
                        groupEmotionBarElement.setAttribute(
                        "data-duration",
                        dataDuration.toString(),
                        );
                    }
                    
                    const validResults = result.filter(
                    (avg) => !isNaN(Date.parse(avg.interval)),
                    );
                    validResults.forEach((average, index) => {
                        let dominantEmotion = "nodata";
                        let maxScore = -1;
                        let allZero = true;
                        
                        if (average.average_emotions) {
                            const emotionEntries = Object.entries(
                            average.average_emotions,
                            );
                            if (emotionEntries.length > 0) {
                                allZero = emotionEntries.every(
                                ([key, score]) =>
                                Number(score) <= 0.0001,
                                );
                            } else {
                                allZero = true;
                            }
                            
                            if (!allZero) {
                                dominantEmotion = "neutral";
                                for (const [emotion, score] of emotionEntries) {
                                    const lowerEmotion =
                                    emotion.toLowerCase();
                                    if (
                                    Number(score) > maxScore &&
                                    emotionColorMap[lowerEmotion] &&
                                    lowerEmotion !== "nodata"
                                    ) {
                                        maxScore = Number(score);
                                        dominantEmotion = lowerEmotion;
                                    }
                                }
                            }
                        }
                        
                        const intervalTimestamp =
                        Date.parse(average.interval) / 1000;
                        let timePercentage = 0;
                        if (dataDuration > 0) {
                            const relativeTime =
                            intervalTimestamp - minDataTimestamp;
                            timePercentage = Math.max(
                            0,
                            Math.min(
                            100,
                            (relativeTime / dataDuration) * 100,
                            ),
                            );
                        } else if (validTimestamps.length === 1) {
                            timePercentage = 50;
                        } else if (validTimestamps.length > 1) {
                            timePercentage = Math.max(
                            0,
                            Math.min(
                            100,
                            (index / (validTimestamps.length - 1)) *
                            100,
                            ),
                            );
                        }
                        emotionData.push({
                            time: timePercentage,
                            emotion: dominantEmotion,
                        });
                    });
                }
            }
            
            const gradientStyle = createEmotionGradient(
            emotionData,
            dataDuration,
            );
            if (groupEmotionBarElement) {
                if (
                typeof gradientStyle === "string" &&
                gradientStyle.length > 0 &&
                gradientStyle.includes(",")
                ) {
                    groupEmotionBarElement.style.backgroundImage =
                    gradientStyle;
                    groupEmotionBarElement.style.display = "block";
                } else {
                    groupEmotionBarElement.style.backgroundImage = `linear-gradient(to right, ${noDataColor}, ${noDataColor})`;
                    groupEmotionBarElement.style.display = "block";
                }
            }
        } catch (error) {
            console.error("Error loading group average emotions:", error);
            if (groupEmotionBarElement) {
                groupEmotionBarElement.style.backgroundImage = `linear-gradient(to right, ${noDataColor}, ${noDataColor})`;
                groupEmotionBarElement.style.display = 'block';
            }
        }
    }

    async function loadMemberList(projectId: string, ownerId: string | null) {
        const memberListElement = document.getElementById("member-list");
        memberListElement.innerHTML = "Loading members...";

        try {
            const project = await chorusAPI.getProjectDetails(projectId);

            const memberPromises = project.members.map((memberId) =>
                chorusAPI.getUserDetailsById(memberId),
            );
            const memberDetails = await Promise.all(memberPromises);
            memberListElement.innerHTML = "";

            const memberReportPromises = memberDetails.map(async (user) => {
                try {
                    const reports = await chorusAPI.getIndividualReports(
                        projectId,
                        user.user_id,
                        1,
                        1,
                    );
                    return { user, reports };
                } catch (reportError) {
                    console.error(`Error loading reports for user ${user.username}:`, reportError);
                    return { user, reports: [], error: true };
                }
            });

            const membersWithReports = await Promise.all(memberReportPromises);

            membersWithReports.forEach(({ user, reports, error }) => {
                const memberContainer = document.createElement("div");
                memberContainer.className = "member-item";

                const memberHeader = document.createElement("div");
                memberHeader.className = "member-header";

                const usernameHeader = document.createElement("h4");
                usernameHeader.textContent = user.username;

                if (ownerId && user.user_id === ownerId) {
                    const ownerLabel = document.createElement("span");
                    ownerLabel.textContent = " (Owner)";
                    ownerLabel.className = "owner-label";
                    usernameHeader.appendChild(ownerLabel);
                }
                memberHeader.appendChild(usernameHeader);

                if (ownerId && user.user_id !== ownerId) {
                    const removeButton = document.createElement("button");
                    removeButton.textContent = "Remove";
                    removeButton.className = "remove-member-button danger-button";
                    removeButton.dataset.userId = user.user_id;
                    removeButton.dataset.username = user.username;
                    removeButton.addEventListener('click', () => {
                        removeMemberHandler(projectId, user.user_id, user.username);
                    });
                    memberHeader.appendChild(removeButton);
                }

                memberContainer.appendChild(memberHeader);

                const reportParagraph = document.createElement("p");
                reportParagraph.className = "report-summary";

                if (error) {
                    reportParagraph.textContent = "Error loading report.";
                    reportParagraph.style.color = "red";
                } else if (reports && reports.length > 0) {
                    const report = reports[0];
                    if (report.is_alarm) {
                        reportParagraph.style.color = "red";
                        reportParagraph.style.fontWeight = "bold";
                        reportParagraph.textContent = report.alarm_message || "Alarm triggered (no message).";
                    } else {
                        reportParagraph.textContent = report.mood_summary || "No summary available.";
                    }
                } else {
                    reportParagraph.textContent = "No recent report found.";
                    reportParagraph.style.fontStyle = "italic";
                }

                memberContainer.appendChild(reportParagraph);
                memberListElement.appendChild(memberContainer);
            });

        } catch (userError) {
            memberListElement.innerHTML =
                "<div class='error-message'>Error loading member details.</div>";
        }
    }

    async function removeMemberHandler(projectId: string, userId: string, username: string) {
        const messageElement = document.getElementById("add-member-message");

        if (!window.confirm(`Are you sure you want to remove ${username} from this project?`)) {
            return;
        }

        messageElement.textContent = `Removing ${username}...`;
        messageElement.className = "message info";

        try {
            await chorusAPI.removeMemberFromProject(projectId, userId);

            messageElement.textContent = `Successfully removed ${username}.`;
            messageElement.className = "message success";

            // Pass the currentOwnerId when reloading the list
            await loadMemberList(projectId, currentOwnerId); 

            setTimeout(() => {
                // Clear message only if it hasn't changed
                 if (messageElement.textContent === `Successfully removed ${username}.`) {
                    messageElement.textContent = "";
                    messageElement.className = "message";
                }
            }, 3000);

        } catch (error: any) {
            console.error(`Error removing member ${username}:`, error);
            messageElement.textContent = `Failed to remove ${username}: ${error.message || 'Unknown error'}`;
            messageElement.className = "message error";
             // Clear message only if it hasn't changed
            setTimeout(() => {
                 if (messageElement.textContent === `Failed to remove ${username}: ${error.message || 'Unknown error'}`) {
                    messageElement.textContent = "";
                    messageElement.className = "message";
                }
            }, 5000);
        }
    }

    async function loadStaticProjectData(projectId: string) {
        const projectNameElement = document.getElementById("project-name");
        const projectDescriptionElement = document.getElementById(
        "project-description",
        );
        const groupMoodTextElement = document.getElementById("group-mood-text");
        
        projectNameElement.textContent = "Loading project...";
        projectDescriptionElement.textContent = "";
        if (groupMoodTextElement) groupMoodTextElement.textContent = "Loading...";
        
        try {
            const project = await chorusAPI.getProjectDetails(projectId);
            currentOwnerId = project.owner_id; // Assign to the outer scope variable
            projectNameElement.textContent = project.name;
            projectDescriptionElement.textContent =
            project.description || "No description available.";
            
            try {
                const groupReports = await chorusAPI.getGroupReports(projectId, 1, 1);
                if (groupMoodTextElement) {
                    if (groupReports && groupReports.length > 0) {
                        groupMoodTextElement.textContent = groupReports[0].mood_summary || "No summary available.";
                        groupMoodTextElement.style.fontStyle = "normal";
                        groupMoodTextElement.style.color = "#333";
                    } else {
                        groupMoodTextElement.textContent = "No recent group report found.";
                        groupMoodTextElement.style.fontStyle = "italic";
                        groupMoodTextElement.style.color = "#555";
                    }
                }
            } catch (groupReportError) {
                console.error("Error loading group report:", groupReportError);
                if (groupMoodTextElement) {
                    groupMoodTextElement.textContent = "Error loading group summary.";
                    groupMoodTextElement.style.color = "red";
                }
            }
            
            // Pass the fetched ownerId to loadMemberList
            await loadMemberList(projectId, currentOwnerId); 
            
        } catch (error) {
            projectNameElement.textContent = "Error";
            projectDescriptionElement.textContent =
            "Failed to load project details.";
            const groupMoodTextElement = document.getElementById("group-mood-text");
            const groupEmotionBarElement = document.querySelector(
            "#group-emotionbar-container .emotion-gradient-bar",
            ) as HTMLElement;
            if (groupMoodTextElement) {
                groupMoodTextElement.textContent = "Error loading data.";
                groupMoodTextElement.style.color = "red";
            }
            if (groupEmotionBarElement) {
                groupEmotionBarElement.style.display = "none";
            }
        }
    }

    async function addUserToProjectHandler(projectId: string) {
        const usernameInput = document.getElementById("new-member-username") as HTMLInputElement;
        const messageElement = document.getElementById("add-member-message");
        const username = usernameInput.value.trim();

        if (!username) {
            messageElement.textContent = "Please enter a username.";
            messageElement.className = "message error";
            return;
        }

        messageElement.textContent = "Adding member...";
        messageElement.className = "message info";

        try {
            const user = await chorusAPI.getUserDetailsByUsername(username);
            if (!user || !user.user_id) {
                 throw new Error(`User '${username}' not found.`);
            }
            await chorusAPI.addMemberToProject(projectId, user.user_id);

            messageElement.textContent = `Successfully added ${username}.`;
            messageElement.className = "message success";
            usernameInput.value = "";

            // Pass the currentOwnerId when reloading the list
            await loadMemberList(projectId, currentOwnerId); 

            setTimeout(() => {
                 // Clear message only if it hasn't changed
                 if (messageElement.textContent === `Successfully added ${username}.`) {
                    messageElement.textContent = "";
                    messageElement.className = "message";
                }
            }, 3000);

        } catch (error: any) {
            console.error("Error adding member:", error);
            messageElement.textContent = `Failed to add member: ${error.message || 'Unknown error'}`;
            messageElement.className = "message error";
             // Clear message only if it hasn't changed
            setTimeout(() => {
                 if (messageElement.textContent === `Failed to add member: ${error.message || 'Unknown error'}`) {
                    messageElement.textContent = "";
                    messageElement.className = "message";
                }
            }, 5000);
        }
    }

    async function deleteProjectHandler(projectId: string) {
        const messageElement = document.getElementById("delete-project-message");
        const deleteButton = document.getElementById("delete-project-button") as HTMLButtonElement;

        messageElement.textContent = "Deleting project...";
        messageElement.className = "message info";
        deleteButton.disabled = true;

        try {
            await chorusAPI.deleteProject(projectId);

            messageElement.textContent = "Project successfully deleted. Redirecting...";
            messageElement.className = "message success";

            setTimeout(() => {
                navigate("/dashboard");
            }, 1000);

        } catch (error: any) {
            console.error("Error deleting project:", error);
            messageElement.textContent = `Failed to delete project: ${error.message || 'Unknown error'}`;
            messageElement.className = "message error";
            deleteButton.disabled = false;
        }
    }
    
    document.addEventListener("astro:page-load", () => {
        currentOwnerId = null; // Reset ownerId on page load
        const urlParams = new URLSearchParams(window.location.search);
        const projectId = urlParams.get("project_id");
        const timeRangeFromUrl = urlParams.get("time_range");
        
        const timeRangeSelect = document.getElementById(
        "time-range",
        ) as HTMLSelectElement;
        const projectNameElement = document.getElementById("project-name");
        const projectDescriptionElement = document.getElementById(
        "project-description",
        );
        const groupEmotionBarElement = document.querySelector(
        "#group-emotionbar-container .emotion-gradient-bar",
        ) as HTMLElement;
        const barWrapper = document.querySelector(
        ".emotion-gradient-bar-wrapper",
        ) as HTMLElement;
        const tooltipElement = document.getElementById(
        "emotion-tooltip",
        ) as HTMLElement;
        const addMemberButton = document.getElementById("add-member-button");
        const addMemberInput = document.getElementById("new-member-username") as HTMLInputElement;
        const deleteProjectButton = document.getElementById("delete-project-button");
        const deleteProjectMessage = document.getElementById("delete-project-message");
        
        if (
        timeRangeFromUrl &&
        [...timeRangeSelect.options].some(
        (opt) => opt.value === timeRangeFromUrl,
        )
        ) {
            timeRangeSelect.value = timeRangeFromUrl;
        } else {
            const defaultTimeRange = timeRangeSelect.value;
            if (timeRangeFromUrl !== defaultTimeRange) {
                const currentUrl = new URL(window.location.href);
                currentUrl.searchParams.set("time_range", defaultTimeRange);
                history.replaceState({}, "", currentUrl.toString());
            }
        }
        
        const initialLoad = () => {
            const selectedTimeRangeValue = timeRangeSelect.value;
            const timeRangeSeconds = parseTimeRangeToSeconds(selectedTimeRangeValue);
            const timeRangeEnd = Math.floor(Date.now() / 1000);
            const timeRangeStart = timeRangeEnd - timeRangeSeconds;
            currentDataTimeRangeEnd = timeRangeEnd;
            
            if (projectId) {
                loadStaticProjectData(projectId).then(() => {
                    loadTimeDependentData(projectId, timeRangeStart, timeRangeEnd);
                });
            }
        };
        
        chorusAPI
        .isLoggedIn()
        .then((isLoggedIn) => {
            if (!isLoggedIn) {
                setTimeout(() => navigate("/login"), 1000);
            } else {
                if (projectId) {
                    initialLoad();
                    
                    timeRangeSelect.addEventListener("change", (event) => {
                        const newTimeRangeValue = (event.target as HTMLSelectElement).value;
                        const currentUrl = new URL(window.location.href);
                        currentUrl.searchParams.set("time_range", newTimeRangeValue);
                        history.pushState({}, "", currentUrl.toString());
                        
                        const timeRangeSeconds = parseTimeRangeToSeconds(newTimeRangeValue);
                        const timeRangeEnd = Math.floor(Date.now() / 1000);
                        const timeRangeStart = timeRangeEnd - timeRangeSeconds;
                        currentDataTimeRangeEnd = timeRangeEnd;
                        
                        loadTimeDependentData(projectId, timeRangeStart, timeRangeEnd);
                    });
                    
                    if (addMemberButton) {
                        addMemberButton.addEventListener("click", () => {
                            addUserToProjectHandler(projectId);
                        });
                    }
                    if (addMemberInput) {
                         addMemberInput.addEventListener("keypress", (event) => {
                            if (event.key === "Enter") {
                                event.preventDefault();
                                addUserToProjectHandler(projectId);
                            }
                        });
                    }

                    if (deleteProjectButton) {
                        deleteProjectButton.addEventListener("click", () => {
                            if (window.confirm("Are you sure you want to delete this project? This action cannot be undone.")) {
                                deleteProjectHandler(projectId);
                            }
                        });
                    }

                    if (barWrapper && groupEmotionBarElement && tooltipElement) {
                        barWrapper.addEventListener(
                        "mousemove",
                        (event) => {
                            if (currentDataTimeRangeEnd !== null) {
                                const selectedTimeRangeValue = timeRangeSelect.value;
                                const durationSeconds = parseTimeRangeToSeconds(selectedTimeRangeValue);
                                const timeRangeEnd = currentDataTimeRangeEnd;
                                const timeRangeStart = timeRangeEnd - durationSeconds;
                                
                                const rect = groupEmotionBarElement.getBoundingClientRect();
                                const x = event.clientX - rect.left;
                                const width = rect.width;
                                const percentage = Math.max(0, Math.min(100, (x / width) * 100));
                                
                                const currentTimestamp = timeRangeStart + (percentage / 100) * durationSeconds;
                                
                                const date = new Date(currentTimestamp * 1000);
                                
                                const options: Intl.DateTimeFormatOptions = {
                                    year: 'numeric',
                                    month: 'long',
                                    day: 'numeric',
                                    hour: 'numeric',
                                    minute: '2-digit',
                                    second: '2-digit',
                                    hour12: true,
                                    timeZone: 'America/Chicago',
                                    timeZoneName: 'short'
                                };
                                const timeString = date.toLocaleString("en-US", options);
                                
                                tooltipElement.textContent = timeString;
                                tooltipElement.style.display = "block";
                                
                                const wrapperRect = barWrapper.getBoundingClientRect();
                                const tooltipWidth = tooltipElement.offsetWidth;
                                let tooltipX = event.clientX - wrapperRect.left - tooltipWidth / 2;
                                tooltipX = Math.max(0, Math.min(tooltipX, wrapperRect.width - tooltipWidth));
                                
                                tooltipElement.style.left = `${tooltipX}px`;
                            } else {
                                tooltipElement.style.display = "none";
                            }
                        },
                        );
                        
                        barWrapper.addEventListener("mouseleave", () => {
                            tooltipElement.style.display = "none";
                        });
                    }
                } else {
                    projectNameElement.textContent = "Error";
                    projectDescriptionElement.textContent =
                    "Invalid project ID.";
                    if (groupEmotionBarElement)
                    groupEmotionBarElement.style.display = "none";
                    const addMemberSection = document.getElementById("add-member-section");
                    if (addMemberSection) addMemberSection.style.display = 'none';
                    if (deleteProjectButton) deleteProjectButton.style.display = 'none';
                    if (deleteProjectMessage) deleteProjectMessage.style.display = 'none';
                }
            }
        })
        .catch((error) => {
            projectNameElement.textContent = "Error";
            projectDescriptionElement.textContent =
            "Could not verify login status.";
            if (groupEmotionBarElement)
            groupEmotionBarElement.style.display = "none";
            const addMemberSection = document.getElementById("add-member-section");
            if (addMemberSection) addMemberSection.style.display = 'none';
            if (deleteProjectButton) deleteProjectButton.style.display = 'none';
            if (deleteProjectMessage) deleteProjectMessage.style.display = 'none';
        });
    });
</script>

<style>
    #project-container {
        padding: 20px;
        font-family: sans-serif;
    }
    
    #project-name {
        font-size: 24px;
        font-weight: bold;
        margin-bottom: 5px;
    }
    
    #project-description {
        margin-top: 0;
        margin-bottom: 20px;
        font-size: 16px;
        color: #555;
    }
    
    #delete-project-button {
        padding: 8px 15px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        transition: background-color 0.2s ease;
    }

    .danger-button {
        background-color: #d9534f;
        color: white;
    }

    .danger-button:hover {
        background-color: #c9302c;
    }

    .danger-button:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
    }

    #delete-project-message {
        min-height: 20px;
    }

    #project-actions-bottom {
        margin-top: 40px;
        padding-top: 20px;
        border-top: 1px solid #eee;
    }

    #group-emotionbar-container {
        margin-top: 20px;
        margin-bottom: 30px;
    }
    
    .emotion-gradient-bar-wrapper {
        position: relative;
        width: 100%;
        margin-bottom: 10px;
    }
    
    .emotion-gradient-bar {
        width: 100%;
        border: 1px solid #ccc;
        border-radius: 5px;
        background-color: #eee;
        display: block;
        height: 30px;
        cursor: crosshair;
    }
    
    #emotion-tooltip {
        display: none;
        position: absolute;
        background-color: rgba(0, 0, 0, 0.75);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
        z-index: 10;
        pointer-events: none;
        bottom: 100%;
        margin-bottom: 5px;
    }
    
    #group-emotionbar-container .emotion-gradient-bar {
        height: 30px;
        margin-bottom: 10px;
    }
    
    #group-emotionbar-key ul {
        list-style-type: none;
        padding: 0;
        margin: 0;
    }
    
    #group-emotionbar-key li {
        display: inline-block;
        margin-right: 15px;
        padding: 4px 0;
        font-size: 14px;
        vertical-align: middle;
    }
    
    #group-emotionbar-key li::before {
        content: "";
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-right: 6px;
        vertical-align: middle;
    }
    
    :root {
        --color-anger: rgb(239, 83, 80);
        --color-disgust: rgb(102, 187, 106);
        --color-fear: rgb(66, 165, 245);
        --color-happiness: rgb(255, 213, 79);
        --color-sadness: rgb(126, 87, 194);
        --color-surprise: rgb(255, 167, 38);
        --color-neutral: rgb(173, 216, 230);
        --color-nodata: rgb(220, 220, 220);
    }
    
    #key-anger::before {
        background-color: var(--color-anger);
    }
    #key-disgust::before {
        background-color: var(--color-disgust);
    }
    #key-fear::before {
        background-color: var(--color-fear);
    }
    #key-happiness::before {
        background-color: var(--color-happiness);
    }
    #key-sadness::before {
        background-color: var(--color-sadness);
    }
    #key-surprise::before {
        background-color: var(--color-surprise);
    }
    #key-neutral::before {
        background-color: var(--color-neutral);
    }
    #key-nodata::before {
        background-color: var(--color-nodata);
    }
    
    h2 {
        margin-top: 30px;
        margin-bottom: 10px;
        font-size: 20px;
    }
    
    #member-list {
        padding-left: 0;
        margin-top: 10px;
    }
    
    .member-item {
        margin-bottom: 25px;
        padding: 15px;
        border: 1px solid #eee;
        border-radius: 8px;
        background-color: #f9f9f9;
        position: relative;
    }

    .member-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 5px;
    }
    
    .member-item h4 {
        margin-top: 0;
        margin-bottom: 0;
        font-size: 18px;
        color: #333;
    }

    .remove-member-button {
        padding: 4px 8px;
        font-size: 12px;
        margin-left: 10px;
    }
    
    .report-summary {
        margin-top: 0;
        margin-bottom: 0;
        font-size: 14px;
        color: #555;
        padding-left: 5px;
    }
    
    #member-list .error-message {
        color: red;
        font-weight: bold;
    }
    
    #group-mood-summary {
        margin-top: 10px;
        margin-bottom: 20px;
        font-size: 16px;
        color: #333;
    }
    
    #group-mood-summary strong {
        margin-right: 5px;
    }
    
    select {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
        text-decoration: none;
        background-color: var(--golden-treasure);
        color: var(--parchment);
        border: none;
        padding: 0.5rem .75rem;
        font-size: 1rem;
        font-weight: 100;
        border-radius: 0.5rem;
        cursor: pointer;
        transition:
            transform 0.2s ease,
            box-shadow 0.3s ease;
        box-shadow: var(--shadow);
        position: relative;
        overflow: hidden;
        z-index: 0;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        color: var(--charcoal);
    }

    select::before {
        content: "";
        position: absolute;
        background: var(--golden-treasure);
        width: 100%;
        height: 0%;
        top: 0;
        left: 0;
        z-index: -1;
        transition: height 0.2s ease;
    }

    select:hover::before {
        height: 100%;
    }

    select:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
    }

    select * {
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }

    #add-member-section {
        margin-bottom: 20px;
        display: flex;
        align-items: center;
        gap: 10px;
    }

    #add-member-section input[type="text"] {
        padding: 8px 12px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 14px;
        flex-grow: 1;
    }

    #add-member-section button {
        padding: 8px 15px;
        background-color: var(--golden-treasure);
        color: var(--charcoal);
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        transition: background-color 0.2s ease;
    }

    #add-member-section button:hover {
        background-color: #e6b800;
    }

    .message {
        margin-left: 10px;
        font-size: 14px;
        padding: 5px 0;
    }
    .message.info {
        color: #31708f;
    }
    .message.success {
        color: #3c763d;
        font-weight: bold;
    }
    .message.error {
        color: #a94442;
        font-weight: bold;
    }

    .owner-label {
        font-size: 0.8em;
        font-weight: normal;
        color: #666;
        margin-left: 5px;
    }
</style>
