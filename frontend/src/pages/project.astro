---
import Layout from "../layouts/Layout.astro";
---

<Layout>
    <div id="project-container">
        <h1 id="project-name">Loading project...</h1>
        <p id="project-description"></p>

        <select id="time-range">
            <option value="5m">Last 5 minutes</option>
            <option value="10m">Last 10 minutes</option>
            <option value="30m" selected>Last 30 minutes</option>
            <option value="1h">Last 1 hour</option>
            <option value="6h">Last 6 hours</option>
            <option value="12h">Last 12 hours</option>
            <option value="24h">Last 24 hours</option>
        </select>
        <div id="group-emotionbar-container">
            <h3>Group Emotion Over Time</h3>
            <div class="emotion-gradient-bar"></div>
            <div id="group-emotionbar-key">
                <ul>
                    <li id="key-anger">Anger</li>
                    <li id="key-disgust">Disgust</li>
                    <li id="key-fear">Fear</li>
                    <li id="key-happiness">Happiness</li>
                    <li id="key-sadness">Sadness</li>
                    <li id="key-surprise">Surprise</li>
                    <li id="key-neutral">Neutral</li>
                    <li id="key-nodata">No Data</li>
                </ul>
            </div>
        </div>

        <h2>Members</h2>
        <div id="member-list">Loading members...</div>
    </div>
</Layout>

<script>
    import { chorusAPI } from "../lib/sdk.js";
    import { navigate } from "astro:transitions/client";

    // --- Emotion Color Map ---
    const newNeutralColor = 'rgb(173, 216, 230)'; // Light Blue for Neutral
    const noDataColor = 'rgb(220, 220, 220)';     // Specific Gray for No Data/Loading

    const emotionColorMap = {
        anger: 'rgb(239, 83, 80)',
        disgust: 'rgb(102, 187, 106)',
        fear: 'rgb(66, 165, 245)',
        happiness: 'rgb(255, 213, 79)',
        happy: 'rgb(255, 213, 79)',
        sadness: 'rgb(126, 87, 194)',
        surprise: 'rgb(255, 167, 38)',
        neutral: newNeutralColor,
        nodata: noDataColor // Add nodata key for easier lookup
    };
    // Use a helper function for color lookup
    function getColor(emotionKey: string): string {
        return emotionColorMap[emotionKey.toLowerCase() as keyof typeof emotionColorMap] || noDataColor;
    }

    // --- Emotion Bar Logic ---

    function createEmotionGradient(emotionData: { time: number; emotion: string }[]) {
        emotionData.sort((a, b) => a.time - b.time);

        if (emotionData.length === 0) {
            return `linear-gradient(to right, ${noDataColor}, ${noDataColor})`;
        }

        const stops = [];
        let lastTime = 0;
        const maxTimeGapPercent = 5;
        const epsilon = 0.001; // Small offset for sharp transitions

        // Handle gap at the start
        if (emotionData[0].time > lastTime + epsilon) {
            stops.push({ time: lastTime, color: noDataColor });
            // End gap just before the first data point
            stops.push({ time: Math.max(lastTime, emotionData[0].time - epsilon), color: noDataColor });
            lastTime = emotionData[0].time;
        }

        // Iterate through the points
        for (let i = 0; i < emotionData.length; i++) {
            const currentPoint = emotionData[i];
            const currentColor = getColor(currentPoint.emotion);
            // Ensure currentTime doesn't go backward due to epsilon adjustments
            const currentTime = Math.max(lastTime, currentPoint.time);

            // Determine the end time for this block
            let blockEndTime = 100;
            let nextPointStartTime = 100;
            let isGapAfter = false;

            if (i + 1 < emotionData.length) {
                nextPointStartTime = emotionData[i + 1].time;
                if (nextPointStartTime - currentTime > maxTimeGapPercent) {
                    // End sharply just after current time if gap follows
                    blockEndTime = Math.min(100, currentTime + epsilon);
                    isGapAfter = true;
                } else {
                    // End just before next point starts
                    blockEndTime = Math.max(currentTime, nextPointStartTime - epsilon);
                }
            } else {
                blockEndTime = 100; // Last point extends to 100%
            }
            // Ensure block end time is not before start time
            blockEndTime = Math.max(currentTime, blockEndTime);

            // Add stops for the current color block
            // Start block at the *later* of lastTime or currentTime
            stops.push({ time: Math.max(lastTime, currentTime), color: currentColor });
            stops.push({ time: blockEndTime, color: currentColor }); // End block

            lastTime = blockEndTime; // Update lastTime to the end of this block

            // If there was a gap after this block
            if (isGapAfter) {
                 // Start gap right after block ends
                 stops.push({ time: blockEndTime, color: noDataColor });
                 // End gap just before next point starts
                 stops.push({ time: Math.max(blockEndTime, nextPointStartTime - epsilon), color: noDataColor });
                 lastTime = nextPointStartTime; // Update lastTime past the gap
            }
        }

         // Ensure start at 0 and end at 100
         if (stops.length === 0 || stops[0].time > 0) {
             stops.unshift({ time: 0, color: noDataColor });
         }
         // Ensure the very last stop reaches 100%
         if (stops.length > 0 && stops[stops.length - 1].time < 100) {
             const lastStop = stops[stops.length - 1];
             // If the last segment wasn't already nodata, add a nodata segment
             if (lastStop.color !== noDataColor) {
                 stops.push({ time: lastStop.time, color: noDataColor });
             }
             stops.push({ time: 100, color: noDataColor });
         } else if (stops.length > 0 && stops[stops.length - 1].time >= 100) {
            // Ensure the last stop is exactly 100 and has the correct color
            const lastStop = stops[stops.length - 1];
             // Remove any stops potentially > 100 due to epsilon
             while(stops.length > 0 && stops[stops.length - 1].time > 100) {
                 stops.pop();
             }
             // Ensure the last stop is 100%
             if (stops.length > 0) {
                 stops[stops.length - 1].time = 100;
             } else {
                 // If all stops were > 100, add a 100% stop
                 stops.push({ time: 100, color: lastStop.color }); // Use color of original last stop
             }

         } else if (stops.length === 0) { // Should not happen if emotionData had items
             stops.push({ time: 0, color: noDataColor });
             stops.push({ time: 100, color: noDataColor });
         }


        // Convert to string format and filter duplicates/redundancies
        const finalStopStrings = [];
        for(let i = 0; i < stops.length; i++) {
            const current = stops[i];
            // Clamp time between 0 and 100, format to few decimal places
            const timePercent = Math.max(0, Math.min(100, current.time)).toFixed(4);
            const stopStr = `${current.color} ${timePercent}%`;

            if (i > 0) {
                const prevStopStr = finalStopStrings[finalStopStrings.length - 1];
                const [, prevTimePercentStr] = prevStopStr.split(" ");
                // Skip if identical to previous stop
                if (stopStr === prevStopStr) {
                    continue;
                }
                // Skip if time is same as previous (browser uses last color at a given time)
                // Allow if it's the very first stop being added (index check implicit)
                if (`${timePercent}%` === prevTimePercentStr) {
                     // Overwrite the previous stop at the same time with this new color
                     finalStopStrings[finalStopStrings.length - 1] = stopStr;
                     continue;
                }
            }
            finalStopStrings.push(stopStr);
        }

         // Ensure 0% and 100% stops exist after filtering
         if (finalStopStrings.length === 0 || !finalStopStrings[0].endsWith(" 0.0000%")) {
             const firstColor = finalStopStrings.length > 0 ? finalStopStrings[0].split(" ")[0] : noDataColor;
             finalStopStrings.unshift(`${firstColor} 0.0000%`);
         }
         // Ensure the very last stop is 100%
         if (finalStopStrings.length > 0 && !finalStopStrings[finalStopStrings.length - 1].endsWith(" 100.0000%")) {
              const lastStopStr = finalStopStrings[finalStopStrings.length - 1];
              const [lastColor, lastTimeStr] = lastStopStr.split(" ");
              // If the last stop is before 100%, extend its color to 100%
              if (parseFloat(lastTimeStr) < 100) {
                   finalStopStrings.push(`${lastColor} 100.0000%`);
              } else {
                  // If last stop is somehow > 100%, correct it (shouldn't happen with clamping)
                  finalStopStrings[finalStopStrings.length - 1] = `${lastColor} 100.0000%`;
              }
         } else if (finalStopStrings.length === 0) {
              finalStopStrings.push(`${noDataColor} 0.0000%`);
              finalStopStrings.push(`${noDataColor} 100.0000%`);
         }
          // Final duplicate check after ensuring 0/100
          const uniqueFinalStops = finalStopStrings.filter((stop, index, arr) => {
            if (index === 0) return true;
            return stop !== arr[index - 1];
        });


        console.log("Generated Gradient Stops:", uniqueFinalStops);
        return `linear-gradient(to right, ${uniqueFinalStops.join(", ")})`;
    }

    // --- End Emotion Bar Logic ---

    // Helper function to parse time range string (e.g., "5m", "1h") to seconds
    function parseTimeRangeToSeconds(timeRangeString: string): number {
        const value = parseInt(timeRangeString.slice(0, -1));
        const unit = timeRangeString.slice(-1).toLowerCase();
        switch (unit) {
            case 'm': return value * 60;
            case 'h': return value * 60 * 60;
            default: return value; // Assume seconds if no unit or unknown
        }
    }

    // --- Data Loading Function ---
    async function loadProjectData(projectId: string) {
        const projectNameElement = document.getElementById("project-name");
        const projectDescriptionElement = document.getElementById("project-description");
        const memberListElement = document.getElementById("member-list");
        const groupEmotionBarElement = document.querySelector("#group-emotionbar-container .emotion-gradient-bar");
        const timeRangeSelect = document.getElementById("time-range") as HTMLSelectElement;

        // Clear previous data / show loading states
        projectNameElement.textContent = "Loading project...";
        projectDescriptionElement.textContent = "";
        memberListElement.innerHTML = "Loading members...";
        if (groupEmotionBarElement) {
            // Use the 'no data' color for the loading state
            groupEmotionBarElement.style.backgroundImage = `linear-gradient(to right, ${noDataColor}, ${noDataColor})`;
        }

        try {
            // Fetch Project Details and Members (only needs to happen once unless members change)
            // Consider caching this if the page structure allows to avoid refetching on time change
            const project = await chorusAPI.getProjectDetails(projectId);
            projectNameElement.textContent = project.name;
            projectDescriptionElement.textContent = project.description || "No description available.";

            // Process Members
            try {
                const memberPromises = project.members.map((memberId) =>
                    chorusAPI.getUserDetailsById(memberId)
                );
                const memberDetails = await Promise.all(memberPromises);
                memberListElement.innerHTML = ""; // Clear loading text
                memberDetails.forEach((user) => {
                    const memberDiv = document.createElement("div");
                    memberDiv.className = "member-item";
                    const usernameText = document.createTextNode(user.username);
                    memberDiv.appendChild(usernameText);
                    memberListElement.appendChild(memberDiv);
                });
            } catch (userError) {
                console.error("Error loading member details:", userError);
                memberListElement.innerHTML = "<div class='error-message'>Error loading some member details.</div>";
            }

            // --- Fetch and Process Emotions based on CURRENT time range selection ---
            const selectedTimeRangeValue = timeRangeSelect.value; // Get current value
            const timeRangeSeconds = parseTimeRangeToSeconds(selectedTimeRangeValue);
            const timeRangeEnd = Math.floor(Date.now() / 1000);
            const timeRangeStart = timeRangeEnd - timeRangeSeconds;

            const result = await chorusAPI.getProjectAverageEmotions(
                projectId,
                timeRangeStart,
                timeRangeEnd,
            );

            const emotionData: { time: number; emotion: string }[] = [];
            const duration = timeRangeEnd - timeRangeStart;

            if (result && result.length > 0 && duration > 0) {
                result.forEach((average) => {
                    let dominantEmotion = 'neutral'; // Default to 'neutral' string key
                    let maxScore = -1;
                    // Ensure average_emotions exists before iterating
                    if (average.average_emotions) {
                        // Find the emotion with the highest score
                        for (const [emotion, score] of Object.entries(average.average_emotions)) {
                            const lowerEmotion = emotion.toLowerCase();
                            // Check if score is higher AND the emotion is recognized (in map, excluding 'nodata')
                            if (Number(score) > maxScore && emotionColorMap[lowerEmotion] && lowerEmotion !== 'nodata') {
                                maxScore = Number(score);
                                dominantEmotion = lowerEmotion; // Store lowercase key
                            }
                        }
                         // If maxScore is still <= 0 (or very low), maybe force 'neutral' or 'nodata'?
                         // For now, it defaults to 'neutral' if no positive score found.
                    } else {
                         console.warn("Average object missing 'average_emotions' property:", average);
                         dominantEmotion = 'nodata'; // Treat missing data as 'nodata'
                    }

                    const intervalTimestamp = Date.parse(average.interval) / 1000;
                    // Ensure timestamp is valid
                    if (isNaN(intervalTimestamp)) {
                        console.warn("Invalid interval timestamp received:", average.interval);
                        return; // Skip this data point
                    }
                    const relativeTime = intervalTimestamp - timeRangeStart;
                    const timePercentage = Math.max(0, Math.min(100, (relativeTime / duration) * 100));

                    emotionData.push({ time: timePercentage, emotion: dominantEmotion });
                });
            } else if (duration <= 0) {
                console.warn("Time range duration is zero or negative, cannot calculate percentages.");
                 // emotionData remains empty, gradient function will handle it
            } else {
                console.warn("No average emotions data found in the API response or result array is empty:", result);
                 // emotionData remains empty, gradient function will handle it
            }

            console.log("Processed Emotion Data for Gradient:", emotionData);
            const gradientStyle = createEmotionGradient(emotionData);
            if (groupEmotionBarElement) {
                groupEmotionBarElement.style.backgroundImage = gradientStyle;
            } else {
                console.error("Group emotion bar element not found after loading emotions!");
            }

        } catch (error) {
            console.error("Error loading project data:", error);
            projectNameElement.textContent = "Error";
            projectDescriptionElement.textContent = "Failed to load project details.";
            memberListElement.innerHTML = "";
            if (groupEmotionBarElement) groupEmotionBarElement.style.display = "none"; // Or show error state
        }
    }
    // --- End Data Loading Function ---

    document.addEventListener("astro:page-load", () => {
        chorusAPI
            .isLoggedIn()
            .then((isLoggedIn) => {
                if (!isLoggedIn) {
                    setTimeout(() => {
                        navigate("/login");
                    }, 1000);
                } else {
                    const urlParams = new URLSearchParams(window.location.search);
                    const projectId = urlParams.get("project_id");
                    const timeRangeFromUrl = urlParams.get("time_range");

                    const timeRangeSelect = document.getElementById("time-range") as HTMLSelectElement;
                    const projectNameElement = document.getElementById("project-name");
                    const projectDescriptionElement = document.getElementById("project-description");
                    const memberListElement = document.getElementById("member-list");
                    const groupEmotionBarElement = document.querySelector("#group-emotionbar-container .emotion-gradient-bar");

                    // Set initial time range selection
                    if (timeRangeFromUrl && [...timeRangeSelect.options].some(opt => opt.value === timeRangeFromUrl)) {
                        timeRangeSelect.value = timeRangeFromUrl;
                    } else {
                        // Default to '30m' or whatever is marked 'selected' in HTML
                        // If defaulting, update URL to reflect the default for consistency
                        const defaultTimeRange = timeRangeSelect.value;
                        if (timeRangeFromUrl !== defaultTimeRange) {
                             const currentUrl = new URL(window.location.href);
                             currentUrl.searchParams.set('time_range', defaultTimeRange);
                             // Use replaceState to not pollute history with default setting
                             history.replaceState({}, '', currentUrl.toString());
                        }
                    }

                    if (projectId) {
                        // Initial data load
                        loadProjectData(projectId);

                        // Add event listener for time range changes
                        timeRangeSelect.addEventListener('change', (event) => {
                            const newTimeRange = (event.target as HTMLSelectElement).value;
                            const currentUrl = new URL(window.location.href);
                            currentUrl.searchParams.set('time_range', newTimeRange);
                            // Use pushState to update URL and allow back/forward navigation
                            history.pushState({}, '', currentUrl.toString());

                            // Reload data with the new time range
                            loadProjectData(projectId);
                        });

                    } else {
                        console.error("No project_id found in URL.");
                        projectNameElement.textContent = "Error";
                        projectDescriptionElement.textContent = "Invalid project ID.";
                        memberListElement.innerHTML = "";
                        if (groupEmotionBarElement) groupEmotionBarElement.style.display = "none";
                    }
                }
            })
            .catch((error) => {
                console.error("Error checking login status:", error);
                const projectNameElement = document.getElementById("project-name");
                const projectDescriptionElement = document.getElementById("project-description");
                const memberListElement = document.getElementById("member-list");
                const groupEmotionBarElement = document.querySelector("#group-emotionbar-container .emotion-gradient-bar");

                if (projectNameElement) projectNameElement.textContent = "Error";
                if (projectDescriptionElement) projectDescriptionElement.textContent = "Could not verify login status.";
                if (memberListElement) memberListElement.innerHTML = "";
                if (groupEmotionBarElement) groupEmotionBarElement.style.display = "none";
            });
    });
</script>

<style>
    #project-container {
        padding: 20px;
        font-family: sans-serif;
    }

    #project-name {
        font-size: 24px;
        font-weight: bold;
        margin-bottom: 5px;
    }

    #project-description {
        margin-top: 0;
        margin-bottom: 20px;
        font-size: 16px;
        color: #555;
    }

    #group-emotionbar-container {
        margin-top: 20px;
        margin-bottom: 30px;
    }

    .emotion-gradient-bar {
        width: 100%;
        border: 1px solid #ccc;
        border-radius: 5px;
        background-color: #eee;
        display: block;
    }

    #group-emotionbar-container .emotion-gradient-bar {
        height: 30px;
        margin-bottom: 10px;
    }

    #group-emotionbar-key ul {
        list-style-type: none;
        padding: 0;
        margin: 0;
    }

    #group-emotionbar-key li {
        display: inline-block;
        margin-right: 15px;
        padding: 4px 0;
        font-size: 14px;
        vertical-align: middle;
    }

    #group-emotionbar-key li::before {
        content: "";
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-right: 6px;
        vertical-align: middle;
    }

    :root {
        --color-anger: rgb(239, 83, 80);
        --color-disgust: rgb(102, 187, 106);
        --color-fear: rgb(66, 165, 245);
        --color-happiness: rgb(255, 213, 79);
        --color-sadness: rgb(126, 87, 194);
        --color-surprise: rgb(255, 167, 38);
        --color-neutral: rgb(173, 216, 230);
        --color-nodata: rgb(220, 220, 220);
    }

    #key-anger::before {
        background-color: var(--color-anger);
    }
    #key-disgust::before {
        background-color: var(--color-disgust);
    }
    #key-fear::before {
        background-color: var(--color-fear);
    }
    #key-happiness::before {
        background-color: var(--color-happiness);
    }
    #key-sadness::before {
        background-color: var(--color-sadness);
    }
    #key-surprise::before {
        background-color: var(--color-surprise);
    }
    #key-neutral::before {
        background-color: var(--color-neutral); /* This will now use the light blue */
    }
    #key-nodata::before {
        background-color: var(--color-nodata);
    }

    h2 {
        margin-top: 20px;
        margin-bottom: 10px;
        font-size: 20px;
    }

    #member-list {
        padding-left: 0;
    }

    #member-list > div,
    #member-list .member-item {
        margin-bottom: 15px;
        display: block;
    }

    #member-list .error-message {
        color: red;
    }
</style>
