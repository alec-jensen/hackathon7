---
import Layout from "../layouts/Layout.astro";
---

<Layout>
    <div id="project-container">
        <h1 id="project-name">Loading project...</h1>
        <p id="project-description"></p>

        <select id="time-range">
            <option value="10m">Last 10 minutes</option>
            <option value="30m" selected>Last 30 minutes</option>
            <option value="1h">Last 1 hour</option>
            <option value="6h">Last 6 hours</option>
            <option value="12h">Last 12 hours</option>
            <option value="24h">Last 24 hours</option>
        </select>
        <div id="group-emotionbar-container">
            <h3>Group Emotion Over Time</h3>
            <div class="emotion-gradient-bar"></div>
            <div id="group-emotionbar-key">
                <ul>
                    <li id="key-anger">Anger</li>
                    <li id="key-disgust">Disgust</li>
                    <li id="key-fear">Fear</li>
                    <li id="key-happiness">Happiness</li>
                    <li id="key-sadness">Sadness</li>
                    <li id="key-surprise">Surprise</li>
                    <li id="key-neutral">Neutral</li>
                    <li id="key-nodata">No Data</li>
                </ul>
            </div>
        </div>

        <h2>Members</h2>
        <div id="member-list">Loading members...</div>
    </div>
</Layout>

<script>
    import { chorusAPI } from "../lib/sdk.js";
    import { navigate } from "astro:transitions/client";

    // --- Emotion Color Map ---
    const newNeutralColor = 'rgb(173, 216, 230)'; // Light Blue for Neutral
    const noDataColor = 'rgb(220, 220, 220)';     // Specific Gray for No Data/Loading

    const emotionColorMap = {
        anger: 'rgb(239, 83, 80)',
        disgust: 'rgb(102, 187, 106)',
        fear: 'rgb(66, 165, 245)',
        happiness: 'rgb(255, 213, 79)',
        happy: 'rgb(255, 213, 79)',
        sadness: 'rgb(126, 87, 194)',
        surprise: 'rgb(255, 167, 38)',
        neutral: newNeutralColor,
        nodata: noDataColor // Add nodata key for easier lookup
    };
    // Use a helper function for color lookup
    function getColor(emotionKey: string): string {
        return emotionColorMap[emotionKey.toLowerCase() as keyof typeof emotionColorMap] || noDataColor;
    }

    // --- Emotion Bar Logic ---

    function createEmotionGradient(emotionData: { time: number; emotion: string }[], dataDuration: number) {
        emotionData.sort((a, b) => a.time - b.time);

        if (emotionData.length === 0) {
            return `linear-gradient(to right, ${noDataColor}, ${noDataColor})`;
        }

        const stops: { time: number; color: string }[] = [];
        const maxTimeGapPercent = 15; // Threshold for showing 'no data' gap
        const epsilon = 0.001; // Small offset for sharp transitions

        // Handle gap at the start
        if (emotionData[0].time > 0) {
            if (emotionData[0].time > maxTimeGapPercent) {
                stops.push({ time: 0, color: noDataColor });
                stops.push({ time: Math.max(0, emotionData[0].time - epsilon), color: noDataColor });
            } else {
                stops.push({ time: 0, color: getColor(emotionData[0].emotion) });
            }
        } else {
            stops.push({ time: 0, color: getColor(emotionData[0].emotion) });
        }

        // Iterate through points to add stops and handle gaps
        for (let i = 0; i < emotionData.length; i++) {
            const currentPoint = emotionData[i];
            const currentColor = getColor(currentPoint.emotion);

            const lastStopTime = stops.length > 0 ? stops[stops.length - 1].time : -1;
            if (currentPoint.time > lastStopTime) {
                stops.push({ time: currentPoint.time, color: currentColor });
            } else if (currentPoint.time === lastStopTime && stops[stops.length - 1].color !== currentColor) {
                stops[stops.length - 1].color = currentColor;
            }

            if (i + 1 < emotionData.length) {
                const nextPoint = emotionData[i + 1];
                const timeGap = nextPoint.time - currentPoint.time;

                if (timeGap > maxTimeGapPercent) {
                    const gapStartTime = Math.min(100, currentPoint.time + epsilon);
                    const gapEndTime = Math.max(gapStartTime, nextPoint.time - epsilon);

                    if (gapStartTime > currentPoint.time) {
                        stops.push({ time: gapStartTime, color: currentColor });
                    }
                    stops.push({ time: gapStartTime, color: noDataColor });
                    stops.push({ time: gapEndTime, color: noDataColor });
                }
            }
        }

        // Handle gap at the end
        const lastPoint = emotionData[emotionData.length - 1];
        if (lastPoint.time < 100) {
            if (100 - lastPoint.time > maxTimeGapPercent) {
                const gapStartTime = Math.min(100, lastPoint.time + epsilon);
                if (gapStartTime > lastPoint.time) {
                    stops.push({ time: gapStartTime, color: getColor(lastPoint.emotion) });
                }
                stops.push({ time: gapStartTime, color: noDataColor });
                stops.push({ time: 100, color: noDataColor });
            } else {
                stops.push({ time: 100, color: getColor(lastPoint.emotion) });
            }
        }

        // --- Simplified Filtering and Formatting ---
        const finalStopStrings = [];
        stops.sort((a, b) => a.time - b.time);

        for (let i = 0; i < stops.length; i++) {
            const current = stops[i];
            const timePercent = Math.max(0, Math.min(100, current.time)).toFixed(4);
            const stopStr = `${current.color} ${timePercent}%`;

            if (finalStopStrings.length > 0) {
                const prevStopStr = finalStopStrings[finalStopStrings.length - 1];
                const [, prevTimePercentStr] = prevStopStr.split(" ");

                if (`${timePercent}%` === prevTimePercentStr) {
                    finalStopStrings[finalStopStrings.length - 1] = stopStr;
                    continue;
                }
                if (stopStr === prevStopStr) {
                    continue;
                }
            }
            finalStopStrings.push(stopStr);
        }

        if (finalStopStrings.length === 0 || !finalStopStrings[0].endsWith(" 0.0000%")) {
            let firstColor = noDataColor;
            if (finalStopStrings.length > 0) {
                const [color, timeStr] = finalStopStrings[0].split(" ");
                if (parseFloat(timeStr) === 0) {
                    firstColor = color;
                }
            }
            finalStopStrings.unshift(`${firstColor} 0.0000%`);
        }
        if (finalStopStrings.length === 0 || !finalStopStrings[finalStopStrings.length - 1].endsWith(" 100.0000%")) {
            let lastColor = noDataColor;
            if (finalStopStrings.length > 0) {
                const [color, timeStr] = finalStopStrings[finalStopStrings.length - 1].split(" ");
                if (parseFloat(timeStr) === 100) {
                    lastColor = color;
                } else {
                    lastColor = color;
                }
            }
            const [, lastTimeStr] = finalStopStrings[finalStopStrings.length - 1].split(" ");
            if (parseFloat(lastTimeStr) < 100) {
                finalStopStrings.push(`${lastColor} 100.0000%`);
            }
        }

        const uniqueFinalStops = finalStopStrings.filter((stop, index, arr) => {
            if (index === 0) return true;
            return stop !== arr[index - 1];
        });

        console.log("Generated Gradient Stops:", uniqueFinalStops);
        return `linear-gradient(to right, ${uniqueFinalStops.join(", ")})`;
    }

    // --- End Emotion Bar Logic ---

    // Helper function to parse time range string (e.g., "5m", "1h") to seconds
    function parseTimeRangeToSeconds(timeRangeString: string): number {
        const value = parseInt(timeRangeString.slice(0, -1));
        const unit = timeRangeString.slice(-1).toLowerCase();
        switch (unit) {
            case 'm': return value * 60;
            case 'h': return value * 60 * 60;
            default: return value;
        }
    }

    // --- Data Loading Function ---
    async function loadProjectData(projectId: string) {
        const projectNameElement = document.getElementById("project-name");
        const projectDescriptionElement = document.getElementById("project-description");
        const memberListElement = document.getElementById("member-list");
        const groupEmotionBarElement = document.querySelector("#group-emotionbar-container .emotion-gradient-bar");
        const timeRangeSelect = document.getElementById("time-range") as HTMLSelectElement;

        projectNameElement.textContent = "Loading project...";
        projectDescriptionElement.textContent = "";
        memberListElement.innerHTML = "Loading members...";
        if (groupEmotionBarElement) {
            groupEmotionBarElement.style.backgroundImage = `linear-gradient(to right, ${noDataColor}, ${noDataColor})`;
        }

        try {
            const project = await chorusAPI.getProjectDetails(projectId);
            projectNameElement.textContent = project.name;
            projectDescriptionElement.textContent = project.description || "No description available.";

            try {
                const memberPromises = project.members.map((memberId) =>
                    chorusAPI.getUserDetailsById(memberId)
                );
                const memberDetails = await Promise.all(memberPromises);
                memberListElement.innerHTML = "";
                memberDetails.forEach((user) => {
                    const memberDiv = document.createElement("div");
                    memberDiv.className = "member-item";
                    const usernameText = document.createTextNode(user.username);
                    memberDiv.appendChild(usernameText);
                    memberListElement.appendChild(memberDiv);
                });
            } catch (userError) {
                console.error("Error loading member details:", userError);
                memberListElement.innerHTML = "<div class='error-message'>Error loading some member details.</div>";
            }

            const selectedTimeRangeValue = timeRangeSelect.value;
            const timeRangeSeconds = parseTimeRangeToSeconds(selectedTimeRangeValue);
            const timeRangeEnd = Math.floor(Date.now() / 1000);
            const timeRangeStart = timeRangeEnd - timeRangeSeconds;

            const result = await chorusAPI.getProjectAverageEmotions(
                projectId,
                timeRangeStart,
                timeRangeEnd,
            );

            const emotionData: { time: number; emotion: string }[] = [];
            let dataDuration = 0; // Initialize dataDuration

            console.log("Raw API Result:", result);

            if (result && result.length > 0) {
                let minDataTimestamp = Infinity;
                let maxDataTimestamp = -Infinity;
                const validTimestamps: number[] = [];

                result.forEach((average) => {
                    const ts = Date.parse(average.interval) / 1000;
                    if (!isNaN(ts)) {
                        validTimestamps.push(ts);
                        minDataTimestamp = Math.min(minDataTimestamp, ts);
                        maxDataTimestamp = Math.max(maxDataTimestamp, ts);
                    } else {
                        console.warn("Invalid interval timestamp skipped during min/max calculation:", average.interval);
                    }
                });

                if (validTimestamps.length === 0) {
                    console.warn("No valid timestamps found in API result. Cannot calculate percentages.");
                } else {
                    dataDuration = maxDataTimestamp - minDataTimestamp; // Assign calculated duration
                    console.log(`Data Timestamp Range: ${new Date(minDataTimestamp * 1000).toISOString()} to ${new Date(maxDataTimestamp * 1000).toISOString()}`);
                    console.log(`Actual Data Duration (seconds): ${dataDuration}`);

                    const validResults = result.filter(avg => !isNaN(Date.parse(avg.interval)));

                    validResults.forEach((average, index) => {
                        let dominantEmotion = 'nodata'; // Default to 'nodata'
                        let maxScore = -1;
                        let allZero = true; // Flag to check if all scores are zero

                        // Check if average_emotions exists and is not null
                        if (average.average_emotions) {
                            const emotionEntries = Object.entries(average.average_emotions);

                            // Check if all scores are effectively zero
                            if (emotionEntries.length > 0) {
                                allZero = emotionEntries.every(([key, score]) => Number(score) <= 0.0001); // Use a small threshold for floating point comparison
                            } else {
                                // If average_emotions is an empty object, treat as nodata
                                allZero = true;
                            }

                            if (!allZero) {
                                dominantEmotion = 'neutral'; // Reset to neutral only if scores are not all zero
                                // Find the emotion with the highest score
                                for (const [emotion, score] of emotionEntries) {
                                    const lowerEmotion = emotion.toLowerCase();
                                    // Check if score is higher AND the emotion is recognized (in map, excluding 'nodata')
                                    if (Number(score) > maxScore && emotionColorMap[lowerEmotion] && lowerEmotion !== 'nodata') {
                                        maxScore = Number(score);
                                        dominantEmotion = lowerEmotion; // Store lowercase key
                                    }
                                }
                                // If maxScore remained -1 (or very low), it defaults to 'neutral' from the reset above.
                            } else {
                                // All scores are zero, keep dominantEmotion as 'nodata'
                                console.log(`[${index}] All emotion scores are zero for interval ${average.interval}, treating as 'nodata'.`);
                            }
                        } else {
                            // average_emotions is null or missing, keep dominantEmotion as 'nodata'
                            console.warn(`[${index}] Average object missing or has null 'average_emotions' property:`, average);
                        }

                        const intervalTimestamp = Date.parse(average.interval) / 1000;

                        let timePercentage = 0;

                        if (dataDuration > 0) {
                            const relativeTime = intervalTimestamp - minDataTimestamp;
                            timePercentage = Math.max(0, Math.min(100, (relativeTime / dataDuration) * 100));
                            console.log(`[${index}] Interval: ${average.interval}, Timestamp: ${intervalTimestamp}, MinDataTS: ${minDataTimestamp}, Relative: ${relativeTime}, DataDuration: ${dataDuration}, Percentage: ${timePercentage}`);
                        } else {
                            if (validTimestamps.length === 1) {
                                timePercentage = 50;
                                console.log(`[${index}] Interval: ${average.interval}, Timestamp: ${intervalTimestamp}, DataDuration is 0 (single point), setting Percentage to 50`);
                            } else if (validTimestamps.length > 1) {
                                timePercentage = Math.max(0, Math.min(100, (index / (validTimestamps.length - 1)) * 100));
                                console.log(`[${index}] Interval: ${average.interval}, Timestamp: ${intervalTimestamp}, DataDuration is 0 (multiple points), setting Percentage to ${timePercentage}`);
                            }
                        }

                        emotionData.push({ time: timePercentage, emotion: dominantEmotion });
                    });
                }
            } else {
                console.warn("No average emotions data found in the API response or result array is empty:", result);
            }

            console.log("Processed Emotion Data for Gradient:", emotionData);
            const gradientStyle = createEmotionGradient(emotionData, dataDuration);
            if (groupEmotionBarElement) {
                groupEmotionBarElement.style.backgroundImage = gradientStyle;
            } else {
                console.error("Group emotion bar element not found after loading emotions!");
            }

        } catch (error) {
            console.error("Error loading project data:", error);
            projectNameElement.textContent = "Error";
            projectDescriptionElement.textContent = "Failed to load project details.";
            memberListElement.innerHTML = "";
            if (groupEmotionBarElement) groupEmotionBarElement.style.display = "none";
        }
    }
    // --- End Data Loading Function ---

    document.addEventListener("astro:page-load", () => {
        chorusAPI
            .isLoggedIn()
            .then((isLoggedIn) => {
                if (!isLoggedIn) {
                    setTimeout(() => {
                        navigate("/login");
                    }, 1000);
                } else {
                    const urlParams = new URLSearchParams(window.location.search);
                    const projectId = urlParams.get("project_id");
                    const timeRangeFromUrl = urlParams.get("time_range");

                    const timeRangeSelect = document.getElementById("time-range") as HTMLSelectElement;
                    const projectNameElement = document.getElementById("project-name");
                    const projectDescriptionElement = document.getElementById("project-description");
                    const memberListElement = document.getElementById("member-list");
                    const groupEmotionBarElement = document.querySelector("#group-emotionbar-container .emotion-gradient-bar");

                    if (timeRangeFromUrl && [...timeRangeSelect.options].some(opt => opt.value === timeRangeFromUrl)) {
                        timeRangeSelect.value = timeRangeFromUrl;
                    } else {
                        const defaultTimeRange = timeRangeSelect.value;
                        if (timeRangeFromUrl !== defaultTimeRange) {
                            const currentUrl = new URL(window.location.href);
                            currentUrl.searchParams.set('time_range', defaultTimeRange);
                            history.replaceState({}, '', currentUrl.toString());
                        }
                    }

                    if (projectId) {
                        loadProjectData(projectId);

                        timeRangeSelect.addEventListener('change', (event) => {
                            const newTimeRange = (event.target as HTMLSelectElement).value;
                            const currentUrl = new URL(window.location.href);
                            currentUrl.searchParams.set('time_range', newTimeRange);
                            history.pushState({}, '', currentUrl.toString());

                            loadProjectData(projectId);
                        });

                    } else {
                        console.error("No project_id found in URL.");
                        projectNameElement.textContent = "Error";
                        projectDescriptionElement.textContent = "Invalid project ID.";
                        memberListElement.innerHTML = "";
                        if (groupEmotionBarElement) groupEmotionBarElement.style.display = "none";
                    }
                }
            })
            .catch((error) => {
                console.error("Error checking login status:", error);
                const projectNameElement = document.getElementById("project-name");
                const projectDescriptionElement = document.getElementById("project-description");
                const memberListElement = document.getElementById("member-list");
                const groupEmotionBarElement = document.querySelector("#group-emotionbar-container .emotion-gradient-bar");

                if (projectNameElement) projectNameElement.textContent = "Error";
                if (projectDescriptionElement) projectDescriptionElement.textContent = "Could not verify login status.";
                if (memberListElement) memberListElement.innerHTML = "";
                if (groupEmotionBarElement) groupEmotionBarElement.style.display = "none";
            });
    });
</script>

<style>
    #project-container {
        padding: 20px;
        font-family: sans-serif;
    }

    #project-name {
        font-size: 24px;
        font-weight: bold;
        margin-bottom: 5px;
    }

    #project-description {
        margin-top: 0;
        margin-bottom: 20px;
        font-size: 16px;
        color: #555;
    }

    #group-emotionbar-container {
        margin-top: 20px;
        margin-bottom: 30px;
    }

    .emotion-gradient-bar {
        width: 100%;
        border: 1px solid #ccc;
        border-radius: 5px;
        background-color: #eee;
        display: block;
    }

    #group-emotionbar-container .emotion-gradient-bar {
        height: 30px;
        margin-bottom: 10px;
    }

    #group-emotionbar-key ul {
        list-style-type: none;
        padding: 0;
        margin: 0;
    }

    #group-emotionbar-key li {
        display: inline-block;
        margin-right: 15px;
        padding: 4px 0;
        font-size: 14px;
        vertical-align: middle;
    }

    #group-emotionbar-key li::before {
        content: "";
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-right: 6px;
        vertical-align: middle;
    }

    :root {
        --color-anger: rgb(239, 83, 80);
        --color-disgust: rgb(102, 187, 106);
        --color-fear: rgb(66, 165, 245);
        --color-happiness: rgb(255, 213, 79);
        --color-sadness: rgb(126, 87, 194);
        --color-surprise: rgb(255, 167, 38);
        --color-neutral: rgb(173, 216, 230);
        --color-nodata: rgb(220, 220, 220);
    }

    #key-anger::before {
        background-color: var(--color-anger);
    }
    #key-disgust::before {
        background-color: var(--color-disgust);
    }
    #key-fear::before {
        background-color: var(--color-fear);
    }
    #key-happiness::before {
        background-color: var(--color-happiness);
    }
    #key-sadness::before {
        background-color: var(--color-sadness);
    }
    #key-surprise::before {
        background-color: var(--color-surprise);
    }
    #key-neutral::before {
        background-color: var(--color-neutral);
    }
    #key-nodata::before {
        background-color: var(--color-nodata);
    }

    h2 {
        margin-top: 20px;
        margin-bottom: 10px;
        font-size: 20px;
    }

    #member-list {
        padding-left: 0;
    }

    #member-list > div,
    #member-list .member-item {
        margin-bottom: 15px;
        display: block;
    }

    #member-list .error-message {
        color: red;
    }
</style>
