---
import Layout from "../layouts/Layout.astro";
---

<Layout>
    <div id="project-container">
        <h1 id="project-name">Loading project...</h1>
        <p id="project-description"></p>

        <select id="time-range">
            <option value="10m">Last 10 minutes</option>
            <option value="30m" selected>Last 30 minutes</option>
            <option value="1h">Last 1 hour</option>
            <option value="6h">Last 6 hours</option>
            <option value="12h">Last 12 hours</option>
            <option value="24h">Last 24 hours</option>
        </select>
        <div id="group-emotionbar-container">
            <h3>Group Mood Over Time</h3>
            <div class="emotion-gradient-bar-wrapper">
                <div class="emotion-gradient-bar"></div>
                <div id="emotion-tooltip"></div>
            </div>
            <div id="group-emotionbar-key">
                <ul>
                    <li id="key-anger">Anger</li>
                    <li id="key-disgust">Disgust</li>
                    <li id="key-fear">Fear</li>
                    <li id="key-happiness">Happiness</li>
                    <li id="key-sadness">Sadness</li>
                    <li id="key-surprise">Surprise</li>
                    <li id="key-neutral">Neutral</li>
                    <li id="key-nodata">No Data</li>
                </ul>
            </div>
        </div>

        <p id="group-mood-summary">
            <strong>Group Mood Summary:</strong>
            <span id="group-mood-text">Loading...</span>
        </p>

        <h2>Members</h2>
        <div id="member-list">Loading members...</div>
    </div>
</Layout>

<script>
    import { chorusAPI } from "../lib/sdk.js";
    import { navigate } from "astro:transitions/client";

    const newNeutralColor = "rgb(173, 216, 230)";
    const noDataColor = "rgb(220, 220, 220)";

    const emotionColorMap = {
        anger: "rgb(239, 83, 80)",
        disgust: "rgb(102, 187, 106)",
        fear: "rgb(66, 165, 245)",
        happiness: "rgb(255, 213, 79)",
        happy: "rgb(255, 213, 79)",
        sadness: "rgb(126, 87, 194)",
        surprise: "rgb(255, 167, 38)",
        neutral: newNeutralColor,
        nodata: noDataColor,
    };

    function getColor(emotionKey: string): string {
        return (
            emotionColorMap[
                emotionKey.toLowerCase() as keyof typeof emotionColorMap
            ] || noDataColor
        );
    }

    function parseTimeRangeToSeconds(timeRangeString: string): number {
        const value = parseInt(timeRangeString.slice(0, -1));
        const unit = timeRangeString.slice(-1).toLowerCase();
        switch (unit) {
            case "m":
                return value * 60;
            case "h":
                return value * 60 * 60;
            default:
                return value;
        }
    }

    let currentDataTimeRangeEnd: number | null = null;

    function createEmotionGradient(
        emotionData: { time: number; emotion: string }[],
        dataDuration: number,
    ) {
        emotionData.sort((a, b) => a.time - b.time);

        if (emotionData.length === 0) {
            return `linear-gradient(to right, ${noDataColor}, ${noDataColor})`;
        }

        const stops: { time: number; color: string }[] = [];
        const maxTimeGapPercent = 15;
        const epsilon = 0.001;

        if (emotionData[0].time > 0) {
            if (emotionData[0].time > maxTimeGapPercent) {
                stops.push({ time: 0, color: noDataColor });
                stops.push({
                    time: Math.max(0, emotionData[0].time - epsilon),
                    color: noDataColor,
                });
            } else {
                stops.push({
                    time: 0,
                    color: getColor(emotionData[0].emotion),
                });
            }
        } else {
            stops.push({
                time: 0,
                color: getColor(emotionData[0].emotion),
            });
        }

        for (let i = 0; i < emotionData.length; i++) {
            const currentPoint = emotionData[i];
            const currentColor = getColor(currentPoint.emotion);

            const lastStopTime =
                stops.length > 0 ? stops[stops.length - 1].time : -1;
            if (currentPoint.time > lastStopTime) {
                stops.push({
                    time: currentPoint.time,
                    color: currentColor,
                });
            } else if (
                currentPoint.time === lastStopTime &&
                stops[stops.length - 1].color !== currentColor
            ) {
                stops[stops.length - 1].color = currentColor;
            }

            if (i + 1 < emotionData.length) {
                const nextPoint = emotionData[i + 1];
                const timeGap = nextPoint.time - currentPoint.time;

                if (timeGap > maxTimeGapPercent) {
                    const gapStartTime = Math.min(
                        100,
                        currentPoint.time + epsilon,
                    );
                    const gapEndTime = Math.max(
                        gapStartTime,
                        nextPoint.time - epsilon,
                    );

                    if (gapStartTime > currentPoint.time) {
                        stops.push({
                            time: gapStartTime,
                            color: currentColor,
                        });
                    }
                    stops.push({ time: gapStartTime, color: noDataColor });
                    stops.push({ time: gapEndTime, color: noDataColor });
                }
            }
        }

        const lastPoint = emotionData[emotionData.length - 1];
        if (lastPoint.time < 100) {
            if (100 - lastPoint.time > maxTimeGapPercent) {
                const gapStartTime = Math.min(
                    100,
                    lastPoint.time + epsilon,
                );
                if (gapStartTime > lastPoint.time) {
                    stops.push({
                        time: gapStartTime,
                        color: getColor(lastPoint.emotion),
                    });
                }
                stops.push({ time: gapStartTime, color: noDataColor });
                stops.push({ time: 100, color: noDataColor });
            } else {
                stops.push({
                    time: 100,
                    color: getColor(lastPoint.emotion),
                });
            }
        }

        const finalStopStrings = [];
        stops.sort((a, b) => a.time - b.time);

        for (let i = 0; i < stops.length; i++) {
            const current = stops[i];
            const timePercent = Math.max(
                0,
                Math.min(100, current.time),
            ).toFixed(4);
            const stopStr = `${current.color} ${timePercent}%`;

            if (finalStopStrings.length > 0) {
                const prevStopStr =
                    finalStopStrings[finalStopStrings.length - 1];
                const [, prevTimePercentStr] = prevStopStr.split(" ");

                if (`${timePercent}%` === prevTimePercentStr) {
                    finalStopStrings[finalStopStrings.length - 1] = stopStr;
                    continue;
                }
                if (stopStr === prevStopStr) {
                    continue;
                }
            }
            finalStopStrings.push(stopStr);
        }

        if (
            finalStopStrings.length === 0 ||
            !finalStopStrings[0].endsWith(" 0.0000%")
        ) {
            let firstColor = noDataColor;
            if (finalStopStrings.length > 0) {
                const [color, timeStr] = finalStopStrings[0].split(" ");
                if (parseFloat(timeStr) === 0) {
                    firstColor = color;
                }
            }
            finalStopStrings.unshift(`${firstColor} 0.0000%`);
        }
        if (
            finalStopStrings.length === 0 ||
            !finalStopStrings[finalStopStrings.length - 1].endsWith(
                " 100.0000%",
            )
        ) {
            let lastColor = noDataColor;
            if (finalStopStrings.length > 0) {
                const [color, timeStr] =
                    finalStopStrings[finalStopStrings.length - 1].split(" ");
                if (parseFloat(timeStr) === 100) {
                    lastColor = color;
                } else {
                    lastColor = color;
                }
            }
            const [, lastTimeStr] =
                finalStopStrings[finalStopStrings.length - 1].split(" ");
            if (parseFloat(lastTimeStr) < 100) {
                finalStopStrings.push(`${lastColor} 100.0000%`);
            }
        }

        const uniqueFinalStops = finalStopStrings.filter(
            (stop, index, arr) => {
                if (index === 0) return true;
                return stop !== arr[index - 1];
            },
        );

        if (uniqueFinalStops.length < 2) {
            return `linear-gradient(to right, ${noDataColor}, ${noDataColor})`;
        }

        const gradientString = `linear-gradient(to right, ${uniqueFinalStops.join(
            ", ",
        )})`;
        return gradientString;
    }

    async function loadTimeDependentData(
        projectId: string,
        timeRangeStart: number,
        timeRangeEnd: number,
    ) {
        const groupEmotionBarElement = document.querySelector(
            "#group-emotionbar-container .emotion-gradient-bar",
        ) as HTMLElement;

        if (groupEmotionBarElement) {
            groupEmotionBarElement.style.backgroundImage = `linear-gradient(to right, ${noDataColor}, ${noDataColor})`;
            groupEmotionBarElement.removeAttribute("data-min-ts");
            groupEmotionBarElement.removeAttribute("data-duration");
        }

        try {
            const result = await chorusAPI.getProjectAverageEmotions(
                projectId,
                timeRangeStart,
                timeRangeEnd,
            );

            const emotionData: { time: number; emotion: string }[] = [];
            let dataDuration = 0;
            let minDataTimestamp = Infinity;
            let maxDataTimestamp = -Infinity;

            if (result && result.length > 0) {
                const validTimestamps: number[] = [];
                result.forEach((average) => {
                    const ts = Date.parse(average.interval) / 1000;
                    if (!isNaN(ts)) {
                        validTimestamps.push(ts);
                        minDataTimestamp = Math.min(minDataTimestamp, ts);
                        maxDataTimestamp = Math.max(maxDataTimestamp, ts);
                    }
                });

                if (validTimestamps.length > 0) {
                    dataDuration = maxDataTimestamp - minDataTimestamp;

                    if (groupEmotionBarElement) {
                        groupEmotionBarElement.setAttribute(
                            "data-min-ts",
                            minDataTimestamp.toString(),
                        );
                        groupEmotionBarElement.setAttribute(
                            "data-duration",
                            dataDuration.toString(),
                        );
                    }

                    const validResults = result.filter(
                        (avg) => !isNaN(Date.parse(avg.interval)),
                    );
                    validResults.forEach((average, index) => {
                        let dominantEmotion = "nodata";
                        let maxScore = -1;
                        let allZero = true;

                        if (average.average_emotions) {
                            const emotionEntries = Object.entries(
                                average.average_emotions,
                            );
                            if (emotionEntries.length > 0) {
                                allZero = emotionEntries.every(
                                    ([key, score]) =>
                                        Number(score) <= 0.0001,
                                );
                            } else {
                                allZero = true;
                            }

                            if (!allZero) {
                                dominantEmotion = "neutral";
                                for (const [emotion, score] of emotionEntries) {
                                    const lowerEmotion =
                                        emotion.toLowerCase();
                                    if (
                                        Number(score) > maxScore &&
                                        emotionColorMap[lowerEmotion] &&
                                        lowerEmotion !== "nodata"
                                    ) {
                                        maxScore = Number(score);
                                        dominantEmotion = lowerEmotion;
                                    }
                                }
                            }
                        }

                        const intervalTimestamp =
                            Date.parse(average.interval) / 1000;
                        let timePercentage = 0;
                        if (dataDuration > 0) {
                            const relativeTime =
                                intervalTimestamp - minDataTimestamp;
                            timePercentage = Math.max(
                                0,
                                Math.min(
                                    100,
                                    (relativeTime / dataDuration) * 100,
                                ),
                            );
                        } else if (validTimestamps.length === 1) {
                            timePercentage = 50;
                        } else if (validTimestamps.length > 1) {
                            timePercentage = Math.max(
                                0,
                                Math.min(
                                    100,
                                    (index / (validTimestamps.length - 1)) *
                                        100,
                                ),
                            );
                        }
                        emotionData.push({
                            time: timePercentage,
                            emotion: dominantEmotion,
                        });
                    });
                }
            }

            const gradientStyle = createEmotionGradient(
                emotionData,
                dataDuration,
            );
            if (groupEmotionBarElement) {
                if (
                    typeof gradientStyle === "string" &&
                    gradientStyle.length > 0 &&
                    gradientStyle.includes(",")
                ) {
                    groupEmotionBarElement.style.backgroundImage =
                        gradientStyle;
                    groupEmotionBarElement.style.display = "block";
                } else {
                    groupEmotionBarElement.style.backgroundImage = `linear-gradient(to right, ${noDataColor}, ${noDataColor})`;
                    groupEmotionBarElement.style.display = "block";
                }
            }
        } catch (error) {
            console.error("Error loading group average emotions:", error);
            if (groupEmotionBarElement) {
                groupEmotionBarElement.style.backgroundImage = `linear-gradient(to right, ${noDataColor}, ${noDataColor})`;
                groupEmotionBarElement.style.display = 'block';
            }
        }
    }

    async function loadStaticProjectData(projectId: string) {
        const projectNameElement = document.getElementById("project-name");
        const projectDescriptionElement = document.getElementById(
            "project-description",
        );
        const memberListElement = document.getElementById("member-list");
        const groupMoodTextElement = document.getElementById("group-mood-text");

        projectNameElement.textContent = "Loading project...";
        projectDescriptionElement.textContent = "";
        memberListElement.innerHTML = "Loading members...";
        if (groupMoodTextElement) groupMoodTextElement.textContent = "Loading...";

        try {
            const project = await chorusAPI.getProjectDetails(projectId);
            projectNameElement.textContent = project.name;
            projectDescriptionElement.textContent =
                project.description || "No description available.";

            try {
                const groupReports = await chorusAPI.getGroupReports(projectId, 1, 1);
                if (groupMoodTextElement) {
                    if (groupReports && groupReports.length > 0) {
                        groupMoodTextElement.textContent = groupReports[0].mood_summary || "No summary available.";
                        groupMoodTextElement.style.fontStyle = "normal";
                        groupMoodTextElement.style.color = "#333";
                    } else {
                        groupMoodTextElement.textContent = "No recent group report found.";
                        groupMoodTextElement.style.fontStyle = "italic";
                        groupMoodTextElement.style.color = "#555";
                    }
                }
            } catch (groupReportError) {
                console.error("Error loading group report:", groupReportError);
                if (groupMoodTextElement) {
                    groupMoodTextElement.textContent = "Error loading group summary.";
                    groupMoodTextElement.style.color = "red";
                }
            }

            try {
                const memberPromises = project.members.map((memberId) =>
                    chorusAPI.getUserDetailsById(memberId),
                );
                const memberDetails = await Promise.all(memberPromises);
                memberListElement.innerHTML = "";

                const memberReportPromises = memberDetails.map(async (user) => {
                    try {
                        const reports = await chorusAPI.getIndividualReports(
                            projectId,
                            user.user_id,
                            1,
                            1,
                        );
                        return { user, reports };
                    } catch (reportError) {
                        console.error(`Error loading reports for user ${user.username}:`, reportError);
                        return { user, reports: [], error: true };
                    }
                });

                const membersWithReports = await Promise.all(memberReportPromises);

                membersWithReports.forEach(({ user, reports, error }) => {
                    const memberContainer = document.createElement("div");
                    memberContainer.className = "member-item";

                    const usernameHeader = document.createElement("h4");
                    usernameHeader.textContent = user.username;
                    memberContainer.appendChild(usernameHeader);

                    const reportParagraph = document.createElement("p");
                    reportParagraph.className = "report-summary";

                    if (error) {
                        reportParagraph.textContent = "Error loading report.";
                        reportParagraph.style.color = "red";
                    } else if (reports && reports.length > 0) {
                        const report = reports[0];
                        if (report.is_alarm) {
                            reportParagraph.style.color = "red";
                            reportParagraph.style.fontWeight = "bold";
                            reportParagraph.textContent = report.alarm_message || "Alarm triggered (no message).";
                        } else {
                            reportParagraph.textContent = report.mood_summary || "No summary available.";
                        }
                    } else {
                        reportParagraph.textContent = "No recent report found.";
                        reportParagraph.style.fontStyle = "italic";
                    }

                    memberContainer.appendChild(reportParagraph);
                    memberListElement.appendChild(memberContainer);
                });

            } catch (userError) {
                memberListElement.innerHTML =
                    "<div class='error-message'>Error loading member details.</div>";
            }

        } catch (error) {
            projectNameElement.textContent = "Error";
            projectDescriptionElement.textContent =
                "Failed to load project details.";
            memberListElement.innerHTML = "";
            const groupMoodTextElement = document.getElementById("group-mood-text");
            const groupEmotionBarElement = document.querySelector(
                "#group-emotionbar-container .emotion-gradient-bar",
            ) as HTMLElement;
            if (groupMoodTextElement) {
                groupMoodTextElement.textContent = "Error loading data.";
                groupMoodTextElement.style.color = "red";
            }
            if (groupEmotionBarElement) {
                groupEmotionBarElement.style.display = "none";
            }
        }
    }

    document.addEventListener("astro:page-load", () => {
        const urlParams = new URLSearchParams(window.location.search);
        const projectId = urlParams.get("project_id");
        const timeRangeFromUrl = urlParams.get("time_range");

        const timeRangeSelect = document.getElementById(
            "time-range",
        ) as HTMLSelectElement;
        const projectNameElement = document.getElementById("project-name");
        const projectDescriptionElement = document.getElementById(
            "project-description",
        );
        const memberListElement = document.getElementById("member-list");
        const groupEmotionBarElement = document.querySelector(
            "#group-emotionbar-container .emotion-gradient-bar",
        ) as HTMLElement;
        const barWrapper = document.querySelector(
            ".emotion-gradient-bar-wrapper",
        ) as HTMLElement;
        const tooltipElement = document.getElementById(
            "emotion-tooltip",
        ) as HTMLElement;

        if (
            timeRangeFromUrl &&
            [...timeRangeSelect.options].some(
                (opt) => opt.value === timeRangeFromUrl,
            )
        ) {
            timeRangeSelect.value = timeRangeFromUrl;
        } else {
            const defaultTimeRange = timeRangeSelect.value;
            if (timeRangeFromUrl !== defaultTimeRange) {
                const currentUrl = new URL(window.location.href);
                currentUrl.searchParams.set("time_range", defaultTimeRange);
                history.replaceState({}, "", currentUrl.toString());
            }
        }

        const initialLoad = () => {
            const selectedTimeRangeValue = timeRangeSelect.value;
            const timeRangeSeconds = parseTimeRangeToSeconds(selectedTimeRangeValue);
            const timeRangeEnd = Math.floor(Date.now() / 1000);
            const timeRangeStart = timeRangeEnd - timeRangeSeconds;
            currentDataTimeRangeEnd = timeRangeEnd;

            if (projectId) {
                loadStaticProjectData(projectId).then(() => {
                    loadTimeDependentData(projectId, timeRangeStart, timeRangeEnd);
                });
            }
        };

        chorusAPI
            .isLoggedIn()
            .then((isLoggedIn) => {
                if (!isLoggedIn) {
                    setTimeout(() => navigate("/login"), 1000);
                } else {
                    if (projectId) {
                        initialLoad();

                        timeRangeSelect.addEventListener("change", (event) => {
                            const newTimeRangeValue = (event.target as HTMLSelectElement).value;
                            const currentUrl = new URL(window.location.href);
                            currentUrl.searchParams.set("time_range", newTimeRangeValue);
                            history.pushState({}, "", currentUrl.toString());

                            const timeRangeSeconds = parseTimeRangeToSeconds(newTimeRangeValue);
                            const timeRangeEnd = Math.floor(Date.now() / 1000);
                            const timeRangeStart = timeRangeEnd - timeRangeSeconds;
                            currentDataTimeRangeEnd = timeRangeEnd;

                            loadTimeDependentData(projectId, timeRangeStart, timeRangeEnd);
                        });

                        if (barWrapper && groupEmotionBarElement && tooltipElement) {
                            barWrapper.addEventListener(
                                "mousemove",
                                (event) => {
                                    if (currentDataTimeRangeEnd !== null) {
                                        const selectedTimeRangeValue = timeRangeSelect.value;
                                        const durationSeconds = parseTimeRangeToSeconds(selectedTimeRangeValue);
                                        const timeRangeEnd = currentDataTimeRangeEnd;
                                        const timeRangeStart = timeRangeEnd - durationSeconds;

                                        const rect = groupEmotionBarElement.getBoundingClientRect();
                                        const x = event.clientX - rect.left;
                                        const width = rect.width;
                                        const percentage = Math.max(0, Math.min(100, (x / width) * 100));

                                        const currentTimestamp = timeRangeStart + (percentage / 100) * durationSeconds;

                                        const date = new Date(currentTimestamp * 1000);

                                        const options: Intl.DateTimeFormatOptions = {
                                            year: 'numeric',
                                            month: 'long',
                                            day: 'numeric',
                                            hour: 'numeric',
                                            minute: '2-digit',
                                            second: '2-digit',
                                            hour12: true,
                                            timeZone: 'America/Chicago',
                                            timeZoneName: 'short'
                                        };
                                        const timeString = date.toLocaleString("en-US", options);

                                        tooltipElement.textContent = timeString;
                                        tooltipElement.style.display = "block";

                                        const wrapperRect = barWrapper.getBoundingClientRect();
                                        const tooltipWidth = tooltipElement.offsetWidth;
                                        let tooltipX = event.clientX - wrapperRect.left - tooltipWidth / 2;
                                        tooltipX = Math.max(0, Math.min(tooltipX, wrapperRect.width - tooltipWidth));

                                        tooltipElement.style.left = `${tooltipX}px`;
                                    } else {
                                        tooltipElement.style.display = "none";
                                    }
                                },
                            );

                            barWrapper.addEventListener("mouseleave", () => {
                                tooltipElement.style.display = "none";
                            });
                        }
                    } else {
                        projectNameElement.textContent = "Error";
                        projectDescriptionElement.textContent =
                            "Invalid project ID.";
                        memberListElement.innerHTML = "";
                        if (groupEmotionBarElement)
                            groupEmotionBarElement.style.display = "none";
                    }
                }
            })
            .catch((error) => {
                projectNameElement.textContent = "Error";
                projectDescriptionElement.textContent =
                    "Could not verify login status.";
                memberListElement.innerHTML = "";
                if (groupEmotionBarElement)
                    groupEmotionBarElement.style.display = "none";
            });
    });
</script>

<style>
    #project-container {
        padding: 20px;
        font-family: sans-serif;
    }

    #project-name {
        font-size: 24px;
        font-weight: bold;
        margin-bottom: 5px;
    }

    #project-description {
        margin-top: 0;
        margin-bottom: 20px;
        font-size: 16px;
        color: #555;
    }

    #group-emotionbar-container {
        margin-top: 20px;
        margin-bottom: 30px;
    }

    .emotion-gradient-bar-wrapper {
        position: relative;
        width: 100%;
        margin-bottom: 10px;
    }

    .emotion-gradient-bar {
        width: 100%;
        border: 1px solid #ccc;
        border-radius: 5px;
        background-color: #eee;
        display: block;
        height: 30px;
        cursor: crosshair;
    }

    #emotion-tooltip {
        display: none;
        position: absolute;
        background-color: rgba(0, 0, 0, 0.75);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
        z-index: 10;
        pointer-events: none;
        bottom: 100%;
        margin-bottom: 5px;
    }

    #group-emotionbar-container .emotion-gradient-bar {
        height: 30px;
        margin-bottom: 10px;
    }

    #group-emotionbar-key ul {
        list-style-type: none;
        padding: 0;
        margin: 0;
    }

    #group-emotionbar-key li {
        display: inline-block;
        margin-right: 15px;
        padding: 4px 0;
        font-size: 14px;
        vertical-align: middle;
    }

    #group-emotionbar-key li::before {
        content: "";
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-right: 6px;
        vertical-align: middle;
    }

    :root {
        --color-anger: rgb(239, 83, 80);
        --color-disgust: rgb(102, 187, 106);
        --color-fear: rgb(66, 165, 245);
        --color-happiness: rgb(255, 213, 79);
        --color-sadness: rgb(126, 87, 194);
        --color-surprise: rgb(255, 167, 38);
        --color-neutral: rgb(173, 216, 230);
        --color-nodata: rgb(220, 220, 220);
    }

    #key-anger::before {
        background-color: var(--color-anger);
    }
    #key-disgust::before {
        background-color: var(--color-disgust);
    }
    #key-fear::before {
        background-color: var(--color-fear);
    }
    #key-happiness::before {
        background-color: var(--color-happiness);
    }
    #key-sadness::before {
        background-color: var(--color-sadness);
    }
    #key-surprise::before {
        background-color: var(--color-surprise);
    }
    #key-neutral::before {
        background-color: var(--color-neutral);
    }
    #key-nodata::before {
        background-color: var(--color-nodata);
    }

    h2 {
        margin-top: 30px;
        margin-bottom: 15px;
        font-size: 20px;
    }

    #member-list {
        padding-left: 0;
    }

    .member-item {
        margin-bottom: 25px;
        padding: 15px;
        border: 1px solid #eee;
        border-radius: 8px;
        background-color: #f9f9f9;
    }

    .member-item h4 {
        margin-top: 0;
        margin-bottom: 5px;
        font-size: 18px;
        color: #333;
    }

    .report-summary {
        margin-top: 0;
        margin-bottom: 0;
        font-size: 14px;
        color: #555;
        padding-left: 5px;
    }

    #member-list .error-message {
        color: red;
        font-weight: bold;
    }

    #group-mood-summary {
        margin-top: 10px;
        margin-bottom: 20px;
        font-size: 16px;
        color: #333;
    }

    #group-mood-summary strong {
        margin-right: 5px;
    }
</style>
