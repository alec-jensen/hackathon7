---
import Layout from "../layouts/Layout.astro";
---

<Layout>
    <div id="project-container">
        <h1 id="project-name">Loading project...</h1>
        <p id="project-description"></p>

        <select id="time-range">
            <option value="5m">Last 5 minutes</option>
            <option value="10m">Last 10 minutes</option>
            <option value="30m" selected>Last 30 minutes</option>
            <option value="1h">Last 1 hour</option>
            <option value="6h">Last 6 hours</option>
            <option value="12h">Last 12 hours</option>
            <option value="24h">Last 24 hours</option>
        </select>
        <div id="group-emotionbar-container">
            <h3>Group Emotion Over Time</h3>
            <div class="emotion-gradient-bar"></div>
            <div id="group-emotionbar-key">
                <ul>
                    <li id="key-anger">Anger</li>
                    <li id="key-disgust">Disgust</li>
                    <li id="key-fear">Fear</li>
                    <li id="key-happiness">Happiness</li>
                    <li id="key-sadness">Sadness</li>
                    <li id="key-surprise">Surprise</li>
                    <li id="key-neutral">Neutral</li>
                    <li id="key-nodata">No Data</li>
                </ul>
            </div>
        </div>

        <h2>Members</h2>
        <div id="member-list">Loading members...</div>
    </div>
</Layout>

<script>
    import { chorusAPI } from "../lib/sdk.js";
    import { navigate } from "astro:transitions/client";

    // --- Emotion Color Map ---
    const newNeutralColor = 'rgb(173, 216, 230)'; // Light Blue for Neutral
    const noDataColor = 'rgb(220, 220, 220)';     // Specific Gray for No Data/Loading

    const emotionColorMap = {
        anger: 'rgb(239, 83, 80)',
        disgust: 'rgb(102, 187, 106)',
        fear: 'rgb(66, 165, 245)',
        happiness: 'rgb(255, 213, 79)',
        happy: 'rgb(255, 213, 79)',
        sadness: 'rgb(126, 87, 194)',
        surprise: 'rgb(255, 167, 38)',
        neutral: newNeutralColor,
        nodata: noDataColor // Add nodata key for easier lookup
    };
    // Use a helper function for color lookup
    function getColor(emotionKey) {
        return emotionColorMap[emotionKey.toLowerCase()] || noDataColor;
    }

    // --- Emotion Bar Logic ---

    function createEmotionGradient(emotionData) {
        emotionData.sort((a, b) => a.time - b.time);

        const processedPoints = [];
        // Add a starting point if data doesn't start at 0
        if (emotionData.length === 0 || emotionData[0].time > 0) {
            processedPoints.push({ time: 0, emotion: 'nodata' });
        }
        // Add the actual data points
        processedPoints.push(...emotionData);
        // Add an ending point if data doesn't end at 100
        if (emotionData.length === 0 || emotionData[emotionData.length - 1].time < 100) {
             // Use the last available emotion if it's right before 100, otherwise 'nodata'
             const lastEmotion = (emotionData.length > 0 && emotionData[emotionData.length - 1].time > 99.9)
                               ? emotionData[emotionData.length - 1].emotion
                               : 'nodata';
            processedPoints.push({ time: 100, emotion: lastEmotion });
        }

        if (processedPoints.length === 0) {
             // Should not happen with the logic above, but as a fallback
            return `linear-gradient(to right, ${noDataColor}, ${noDataColor})`;
        }
        if (processedPoints.length === 1) {
             // If only one point (e.g., only start or end 'nodata'), fill bar with its color
            const color = getColor(processedPoints[0].emotion);
            return `linear-gradient(to right, ${color}, ${color})`;
        }


        const gradientStops = [];
        const maxTimeGapPercent = 5; // Threshold: 5% gap is considered large

        // Add the very first stop at 0%
        gradientStops.push(`${getColor(processedPoints[0].emotion)} 0%`);

        for (let i = 0; i < processedPoints.length - 1; i++) {
            const p1 = processedPoints[i];
            const p2 = processedPoints[i + 1];

            const color1 = getColor(p1.emotion);
            const color2 = getColor(p2.emotion);
            const time1 = p1.time;
            const time2 = p2.time;

            // Prevent division by zero or tiny gaps causing issues
            if (time2 <= time1 + 0.001) continue;

            // Check for large gap
            if (time2 - time1 > maxTimeGapPercent) {
                // End previous color block just after its time
                gradientStops.push(`${color1} ${time1}%`);
                // Start noData block immediately
                gradientStops.push(`${noDataColor} ${time1}%`);
                // End noData block just before the next point's time
                gradientStops.push(`${noDataColor} ${time2}%`);
                 // Start next color block at its time
                gradientStops.push(`${color2} ${time2}%`);
            } else {
                 // Small gap or same color: create sharp transition
                 // End previous color block right at the start of the next block
                gradientStops.push(`${color1} ${time2}%`);
                 // Start next color block immediately
                gradientStops.push(`${color2} ${time2}%`);
            }
        }

        // Ensure the final color extends to 100%
        gradientStops.push(`${getColor(processedPoints[processedPoints.length - 1].emotion)} 100%`);

        // Basic filtering of consecutive identical stops (optional, but good practice)
        const finalStops = gradientStops.filter((stop, index, arr) => {
            if (index === 0) return true;
            // Keep stop if it's different from the previous one
            return stop !== arr[index - 1];
        });


        return `linear-gradient(to right, ${finalStops.join(", ")})`;
    }

    // --- End Emotion Bar Logic ---

    // Helper function to parse time range string (e.g., "5m", "1h") to seconds
    function parseTimeRangeToSeconds(timeRangeString: string): number {
        const value = parseInt(timeRangeString.slice(0, -1));
        const unit = timeRangeString.slice(-1).toLowerCase();
        switch (unit) {
            case 'm': return value * 60;
            case 'h': return value * 60 * 60;
            default: return value; // Assume seconds if no unit or unknown
        }
    }

    // --- Data Loading Function ---
    async function loadProjectData(projectId: string) {
        const projectNameElement = document.getElementById("project-name");
        const projectDescriptionElement = document.getElementById("project-description");
        const memberListElement = document.getElementById("member-list");
        const groupEmotionBarElement = document.querySelector("#group-emotionbar-container .emotion-gradient-bar");
        const timeRangeSelect = document.getElementById("time-range") as HTMLSelectElement;

        // Clear previous data / show loading states
        projectNameElement.textContent = "Loading project...";
        projectDescriptionElement.textContent = "";
        memberListElement.innerHTML = "Loading members...";
        if (groupEmotionBarElement) {
            // Use the 'no data' color for the loading state
            groupEmotionBarElement.style.backgroundImage = `linear-gradient(to right, ${noDataColor}, ${noDataColor})`;
        }

        try {
            // Fetch Project Details and Members (only needs to happen once unless members change)
            // Consider caching this if the page structure allows to avoid refetching on time change
            const project = await chorusAPI.getProjectDetails(projectId);
            projectNameElement.textContent = project.name;
            projectDescriptionElement.textContent = project.description || "No description available.";

            // Process Members
            try {
                const memberPromises = project.members.map((memberId) =>
                    chorusAPI.getUserDetailsById(memberId)
                );
                const memberDetails = await Promise.all(memberPromises);
                memberListElement.innerHTML = ""; // Clear loading text
                memberDetails.forEach((user) => {
                    const memberDiv = document.createElement("div");
                    memberDiv.className = "member-item";
                    const usernameText = document.createTextNode(user.username);
                    memberDiv.appendChild(usernameText);
                    memberListElement.appendChild(memberDiv);
                });
            } catch (userError) {
                console.error("Error loading member details:", userError);
                memberListElement.innerHTML = "<div class='error-message'>Error loading some member details.</div>";
            }

            // --- Fetch and Process Emotions based on CURRENT time range selection ---
            const selectedTimeRangeValue = timeRangeSelect.value; // Get current value
            const timeRangeSeconds = parseTimeRangeToSeconds(selectedTimeRangeValue);
            const timeRangeEnd = Math.floor(Date.now() / 1000);
            const timeRangeStart = timeRangeEnd - timeRangeSeconds;

            const result = await chorusAPI.getProjectAverageEmotions(
                projectId,
                timeRangeStart,
                timeRangeEnd,
            );

            const emotionData: { time: number; emotion: string }[] = [];
            const duration = timeRangeEnd - timeRangeStart;

            if (result && result.length > 0 && duration > 0) {
                result.forEach((average) => {
                    let dominantEmotion = 'neutral'; // Default to 'neutral' string key
                    let maxScore = -1;
                    // Ensure average_emotions exists before iterating
                    if (average.average_emotions) {
                        // Find the emotion with the highest score
                        for (const [emotion, score] of Object.entries(average.average_emotions)) {
                            const lowerEmotion = emotion.toLowerCase();
                            // Check if score is higher AND the emotion is recognized (in map, excluding 'nodata')
                            if (Number(score) > maxScore && emotionColorMap[lowerEmotion] && lowerEmotion !== 'nodata') {
                                maxScore = Number(score);
                                dominantEmotion = lowerEmotion; // Store lowercase key
                            }
                        }
                         // If maxScore is still <= 0 (or very low), maybe force 'neutral' or 'nodata'?
                         // For now, it defaults to 'neutral' if no positive score found.
                    } else {
                         console.warn("Average object missing 'average_emotions' property:", average);
                         dominantEmotion = 'nodata'; // Treat missing data as 'nodata'
                    }

                    const intervalTimestamp = Date.parse(average.interval) / 1000;
                    // Ensure timestamp is valid
                    if (isNaN(intervalTimestamp)) {
                        console.warn("Invalid interval timestamp received:", average.interval);
                        return; // Skip this data point
                    }
                    const relativeTime = intervalTimestamp - timeRangeStart;
                    const timePercentage = Math.max(0, Math.min(100, (relativeTime / duration) * 100));

                    emotionData.push({ time: timePercentage, emotion: dominantEmotion });
                });
            } else if (duration <= 0) {
                console.warn("Time range duration is zero or negative, cannot calculate percentages.");
                 // emotionData remains empty, gradient function will handle it
            } else {
                console.warn("No average emotions data found in the API response or result array is empty:", result);
                 // emotionData remains empty, gradient function will handle it
            }

            console.log("Processed Emotion Data for Gradient:", emotionData);
            const gradientStyle = createEmotionGradient(emotionData);
            if (groupEmotionBarElement) {
                groupEmotionBarElement.style.backgroundImage = gradientStyle;
            } else {
                console.error("Group emotion bar element not found after loading emotions!");
            }

        } catch (error) {
            console.error("Error loading project data:", error);
            projectNameElement.textContent = "Error";
            projectDescriptionElement.textContent = "Failed to load project details.";
            memberListElement.innerHTML = "";
            if (groupEmotionBarElement) groupEmotionBarElement.style.display = "none"; // Or show error state
        }
    }
    // --- End Data Loading Function ---

    document.addEventListener("astro:page-load", () => {
        chorusAPI
            .isLoggedIn()
            .then((isLoggedIn) => {
                if (!isLoggedIn) {
                    setTimeout(() => {
                        navigate("/login");
                    }, 1000);
                } else {
                    const urlParams = new URLSearchParams(window.location.search);
                    const projectId = urlParams.get("project_id");
                    const timeRangeFromUrl = urlParams.get("time_range");

                    const timeRangeSelect = document.getElementById("time-range") as HTMLSelectElement;
                    const projectNameElement = document.getElementById("project-name");
                    const projectDescriptionElement = document.getElementById("project-description");
                    const memberListElement = document.getElementById("member-list");
                    const groupEmotionBarElement = document.querySelector("#group-emotionbar-container .emotion-gradient-bar");

                    // Set initial time range selection
                    if (timeRangeFromUrl && [...timeRangeSelect.options].some(opt => opt.value === timeRangeFromUrl)) {
                        timeRangeSelect.value = timeRangeFromUrl;
                    } else {
                        // Default to '30m' or whatever is marked 'selected' in HTML
                        // If defaulting, update URL to reflect the default for consistency
                        const defaultTimeRange = timeRangeSelect.value;
                        if (timeRangeFromUrl !== defaultTimeRange) {
                             const currentUrl = new URL(window.location.href);
                             currentUrl.searchParams.set('time_range', defaultTimeRange);
                             // Use replaceState to not pollute history with default setting
                             history.replaceState({}, '', currentUrl.toString());
                        }
                    }

                    if (projectId) {
                        // Initial data load
                        loadProjectData(projectId);

                        // Add event listener for time range changes
                        timeRangeSelect.addEventListener('change', (event) => {
                            const newTimeRange = (event.target as HTMLSelectElement).value;
                            const currentUrl = new URL(window.location.href);
                            currentUrl.searchParams.set('time_range', newTimeRange);
                            // Use pushState to update URL and allow back/forward navigation
                            history.pushState({}, '', currentUrl.toString());

                            // Reload data with the new time range
                            loadProjectData(projectId);
                        });

                    } else {
                        console.error("No project_id found in URL.");
                        projectNameElement.textContent = "Error";
                        projectDescriptionElement.textContent = "Invalid project ID.";
                        memberListElement.innerHTML = "";
                        if (groupEmotionBarElement) groupEmotionBarElement.style.display = "none";
                    }
                }
            })
            .catch((error) => {
                console.error("Error checking login status:", error);
                const projectNameElement = document.getElementById("project-name");
                const projectDescriptionElement = document.getElementById("project-description");
                const memberListElement = document.getElementById("member-list");
                const groupEmotionBarElement = document.querySelector("#group-emotionbar-container .emotion-gradient-bar");

                if (projectNameElement) projectNameElement.textContent = "Error";
                if (projectDescriptionElement) projectDescriptionElement.textContent = "Could not verify login status.";
                if (memberListElement) memberListElement.innerHTML = "";
                if (groupEmotionBarElement) groupEmotionBarElement.style.display = "none";
            });
    });
</script>

<style>
    #project-container {
        padding: 20px;
        font-family: sans-serif;
    }

    #project-name {
        font-size: 24px;
        font-weight: bold;
        margin-bottom: 5px;
    }

    #project-description {
        margin-top: 0;
        margin-bottom: 20px;
        font-size: 16px;
        color: #555;
    }

    #group-emotionbar-container {
        margin-top: 20px;
        margin-bottom: 30px;
    }

    .emotion-gradient-bar {
        width: 100%;
        border: 1px solid #ccc;
        border-radius: 5px;
        background-color: #eee;
        display: block;
    }

    #group-emotionbar-container .emotion-gradient-bar {
        height: 30px;
        margin-bottom: 10px;
    }

    #group-emotionbar-key ul {
        list-style-type: none;
        padding: 0;
        margin: 0;
    }

    #group-emotionbar-key li {
        display: inline-block;
        margin-right: 15px;
        padding: 4px 0;
        font-size: 14px;
        vertical-align: middle;
    }

    #group-emotionbar-key li::before {
        content: "";
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-right: 6px;
        vertical-align: middle;
    }

    :root {
        --color-anger: rgb(239, 83, 80);
        --color-disgust: rgb(102, 187, 106);
        --color-fear: rgb(66, 165, 245);
        --color-happiness: rgb(255, 213, 79);
        --color-sadness: rgb(126, 87, 194);
        --color-surprise: rgb(255, 167, 38);
        --color-neutral: rgb(173, 216, 230);
        --color-nodata: rgb(220, 220, 220);
    }

    #key-anger::before {
        background-color: var(--color-anger);
    }
    #key-disgust::before {
        background-color: var(--color-disgust);
    }
    #key-fear::before {
        background-color: var(--color-fear);
    }
    #key-happiness::before {
        background-color: var(--color-happiness);
    }
    #key-sadness::before {
        background-color: var(--color-sadness);
    }
    #key-surprise::before {
        background-color: var(--color-surprise);
    }
    #key-neutral::before {
        background-color: var(--color-neutral); /* This will now use the light blue */
    }
    #key-nodata::before {
        background-color: var(--color-nodata);
    }

    h2 {
        margin-top: 20px;
        margin-bottom: 10px;
        font-size: 20px;
    }

    #member-list {
        padding-left: 0;
    }

    #member-list > div,
    #member-list .member-item {
        margin-bottom: 15px;
        display: block;
    }

    #member-list .error-message {
        color: red;
    }
</style>
