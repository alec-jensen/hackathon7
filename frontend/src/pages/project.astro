---
import Layout from "../layouts/Layout.astro";
---

<Layout>
    <div id="project-container">
        <h1 id="project-name">Loading project...</h1>
        <p id="project-description"></p>

        <select id="time-range">
            <option value="10m">Last 10 minutes</option>
            <option value="30m" selected>Last 30 minutes</option>
            <option value="1h">Last 1 hour</option>
            <option value="6h">Last 6 hours</option>
            <option value="12h">Last 12 hours</option>
            <option value="24h">Last 24 hours</option>
        </select>
        <div id="group-emotionbar-container">
            <h3>Group Emotion Over Time</h3>
            <div class="emotion-gradient-bar"></div>
            <div id="group-emotionbar-key">
                <ul>
                    <li id="key-anger">Anger</li>
                    <li id="key-disgust">Disgust</li>
                    <li id="key-fear">Fear</li>
                    <li id="key-happiness">Happiness</li>
                    <li id="key-sadness">Sadness</li>
                    <li id="key-surprise">Surprise</li>
                    <li id="key-neutral">Neutral</li>
                    <li id="key-nodata">No Data</li>
                </ul>
            </div>
        </div>

        <h2>Members</h2>
        <div id="member-list">Loading members...</div>
    </div>
</Layout>

<script>
    import { chorusAPI } from "../lib/sdk.js";
    import { navigate } from "astro:transitions/client";

    // --- Emotion Color Map ---
    const newNeutralColor = 'rgb(173, 216, 230)'; // Light Blue for Neutral
    const noDataColor = 'rgb(220, 220, 220)';     // Specific Gray for No Data/Loading

    const emotionColorMap = {
        anger: 'rgb(239, 83, 80)',
        disgust: 'rgb(102, 187, 106)',
        fear: 'rgb(66, 165, 245)',
        happiness: 'rgb(255, 213, 79)',
        happy: 'rgb(255, 213, 79)',
        sadness: 'rgb(126, 87, 194)',
        surprise: 'rgb(255, 167, 38)',
        neutral: newNeutralColor,
        nodata: noDataColor // Add nodata key for easier lookup
    };
    // Use a helper function for color lookup
    function getColor(emotionKey: string): string {
        return emotionColorMap[emotionKey.toLowerCase() as keyof typeof emotionColorMap] || noDataColor;
    }

    // --- Emotion Bar Logic ---

    function createEmotionGradient(emotionData: { time: number; emotion: string }[]) {
        emotionData.sort((a, b) => a.time - b.time);

        if (emotionData.length === 0) {
            // No data, fill with noDataColor
            return `linear-gradient(to right, ${noDataColor}, ${noDataColor})`;
        }

        const stops: { time: number; color: string }[] = [];

        // Add start point if data doesn't start at 0%
        if (emotionData[0].time > 0) {
            stops.push({ time: 0, color: noDataColor });
        } else {
            // Data starts at 0%, use its color
            stops.push({ time: 0, color: getColor(emotionData[0].emotion) });
        }

        // Add stops for each data point
        emotionData.forEach(point => {
            stops.push({ time: point.time, color: getColor(point.emotion) });
        });

        // Add end point if data doesn't end at 100%
        const lastPoint = emotionData[emotionData.length - 1];
        if (lastPoint.time < 100) {
            stops.push({ time: 100, color: noDataColor });
        } else {
            // Ensure the last point's color extends to 100% if it's already at 100
            if (stops[stops.length - 1].time < 100) {
                stops.push({ time: 100, color: getColor(lastPoint.emotion) });
            }
        }

        // --- Filtering and Formatting ---
        const finalStopStrings = [];
        // Sort stops by time just in case
        stops.sort((a, b) => a.time - b.time);

        for (let i = 0; i < stops.length; i++) {
            const current = stops[i];
            // Clamp time between 0 and 100, format
            const timePercent = Math.max(0, Math.min(100, current.time)).toFixed(4);
            const stopStr = `${current.color} ${timePercent}%`;

            // Basic filtering: remove consecutive identical stops
            if (i > 0 && stopStr === finalStopStrings[finalStopStrings.length - 1]) {
                continue;
            }
            // More advanced filtering: if times are identical, keep only the last color specified
            if (i > 0) {
                const prevStopStr = finalStopStrings[finalStopStrings.length - 1];
                const [, prevTimePercentStr] = prevStopStr.split(" ");
                if (`${timePercent}%` === prevTimePercentStr) {
                    finalStopStrings[finalStopStrings.length - 1] = stopStr; // Overwrite
                    continue;
                }
            }

            finalStopStrings.push(stopStr);
        }

        // Ensure 0% and 100% stops exist after filtering
        if (finalStopStrings.length === 0 || !finalStopStrings[0].endsWith(" 0.0000%")) {
            const firstColor = finalStopStrings.length > 0 ? finalStopStrings[0].split(" ")[0] : noDataColor;
            finalStopStrings.unshift(`${firstColor} 0.0000%`);
        }
        if (finalStopStrings.length === 0 || !finalStopStrings[finalStopStrings.length - 1].endsWith(" 100.0000%")) {
            const lastStopStr = finalStopStrings.length > 0 ? finalStopStrings[finalStopStrings.length - 1] : `${noDataColor} 0.0000%`;
            const [lastColor, lastTimeStr] = lastStopStr.split(" ");
            if (parseFloat(lastTimeStr) < 100) {
                finalStopStrings.push(`${lastColor} 100.0000%`);
            }
        }

        // Remove final duplicates after ensuring 0/100
        const uniqueFinalStops = finalStopStrings.filter((stop, index, arr) => {
            if (index === 0) return true;
            return stop !== arr[index - 1];
        });

        console.log("Generated Gradient Stops:", uniqueFinalStops);
        return `linear-gradient(to right, ${uniqueFinalStops.join(", ")})`;
    }

    // --- End Emotion Bar Logic ---

    // Helper function to parse time range string (e.g., "5m", "1h") to seconds
    function parseTimeRangeToSeconds(timeRangeString: string): number {
        const value = parseInt(timeRangeString.slice(0, -1));
        const unit = timeRangeString.slice(-1).toLowerCase();
        switch (unit) {
            case 'm': return value * 60;
            case 'h': return value * 60 * 60;
            default: return value;
        }
    }

    // --- Data Loading Function ---
    async function loadProjectData(projectId: string) {
        const projectNameElement = document.getElementById("project-name");
        const projectDescriptionElement = document.getElementById("project-description");
        const memberListElement = document.getElementById("member-list");
        const groupEmotionBarElement = document.querySelector("#group-emotionbar-container .emotion-gradient-bar");
        const timeRangeSelect = document.getElementById("time-range") as HTMLSelectElement;

        projectNameElement.textContent = "Loading project...";
        projectDescriptionElement.textContent = "";
        memberListElement.innerHTML = "Loading members...";
        if (groupEmotionBarElement) {
            groupEmotionBarElement.style.backgroundImage = `linear-gradient(to right, ${noDataColor}, ${noDataColor})`;
        }

        try {
            const project = await chorusAPI.getProjectDetails(projectId);
            projectNameElement.textContent = project.name;
            projectDescriptionElement.textContent = project.description || "No description available.";

            try {
                const memberPromises = project.members.map((memberId) =>
                    chorusAPI.getUserDetailsById(memberId)
                );
                const memberDetails = await Promise.all(memberPromises);
                memberListElement.innerHTML = "";
                memberDetails.forEach((user) => {
                    const memberDiv = document.createElement("div");
                    memberDiv.className = "member-item";
                    const usernameText = document.createTextNode(user.username);
                    memberDiv.appendChild(usernameText);
                    memberListElement.appendChild(memberDiv);
                });
            } catch (userError) {
                console.error("Error loading member details:", userError);
                memberListElement.innerHTML = "<div class='error-message'>Error loading some member details.</div>";
            }

            const selectedTimeRangeValue = timeRangeSelect.value;
            const timeRangeSeconds = parseTimeRangeToSeconds(selectedTimeRangeValue);
            const timeRangeEnd = Math.floor(Date.now() / 1000);
            const timeRangeStart = timeRangeEnd - timeRangeSeconds;

            const result = await chorusAPI.getProjectAverageEmotions(
                projectId,
                timeRangeStart,
                timeRangeEnd,
            );

            const emotionData: { time: number; emotion: string }[] = [];

            console.log("Raw API Result:", result);

            if (result && result.length > 0) {
                let minDataTimestamp = Infinity;
                let maxDataTimestamp = -Infinity;
                const validTimestamps: number[] = [];

                result.forEach((average) => {
                    const ts = Date.parse(average.interval) / 1000;
                    if (!isNaN(ts)) {
                        validTimestamps.push(ts);
                        minDataTimestamp = Math.min(minDataTimestamp, ts);
                        maxDataTimestamp = Math.max(maxDataTimestamp, ts);
                    } else {
                        console.warn("Invalid interval timestamp skipped during min/max calculation:", average.interval);
                    }
                });

                if (validTimestamps.length === 0) {
                    console.warn("No valid timestamps found in API result. Cannot calculate percentages.");
                } else {
                    const dataDuration = maxDataTimestamp - minDataTimestamp;
                    console.log(`Data Timestamp Range: ${new Date(minDataTimestamp * 1000).toISOString()} to ${new Date(maxDataTimestamp * 1000).toISOString()}`);
                    console.log(`Actual Data Duration (seconds): ${dataDuration}`);

                    const validResults = result.filter(avg => !isNaN(Date.parse(avg.interval)));

                    validResults.forEach((average, index) => {
                        let dominantEmotion = 'nodata'; // Default to 'nodata'
                        let maxScore = -1;

                        // Check if average_emotions exists and is not null
                        if (average.average_emotions) {
                            dominantEmotion = 'neutral'; // Reset to neutral if data exists but no score is high enough
                            // Find the emotion with the highest score
                            for (const [emotion, score] of Object.entries(average.average_emotions)) {
                                const lowerEmotion = emotion.toLowerCase();
                                // Check if score is higher AND the emotion is recognized (in map, excluding 'nodata')
                                if (Number(score) > maxScore && emotionColorMap[lowerEmotion] && lowerEmotion !== 'nodata') {
                                    maxScore = Number(score);
                                    dominantEmotion = lowerEmotion; // Store lowercase key
                                }
                            }
                             // If maxScore remained -1 (or very low), it defaults to 'neutral' from the reset above.
                        } else {
                            // average_emotions is null or missing, keep dominantEmotion as 'nodata'
                            console.warn(`[${index}] Average object missing or has null 'average_emotions' property:`, average);
                        }

                        const intervalTimestamp = Date.parse(average.interval) / 1000;

                        let timePercentage = 0;

                        if (dataDuration > 0) {
                            const relativeTime = intervalTimestamp - minDataTimestamp;
                            timePercentage = Math.max(0, Math.min(100, (relativeTime / dataDuration) * 100));
                            console.log(`[${index}] Interval: ${average.interval}, Timestamp: ${intervalTimestamp}, MinDataTS: ${minDataTimestamp}, Relative: ${relativeTime}, DataDuration: ${dataDuration}, Percentage: ${timePercentage}`);
                        } else {
                            if (validTimestamps.length === 1) {
                                timePercentage = 50;
                                console.log(`[${index}] Interval: ${average.interval}, Timestamp: ${intervalTimestamp}, DataDuration is 0 (single point), setting Percentage to 50`);
                            } else if (validTimestamps.length > 1) {
                                timePercentage = Math.max(0, Math.min(100, (index / (validTimestamps.length - 1)) * 100));
                                console.log(`[${index}] Interval: ${average.interval}, Timestamp: ${intervalTimestamp}, DataDuration is 0 (multiple points), setting Percentage to ${timePercentage}`);
                            }
                        }

                        emotionData.push({ time: timePercentage, emotion: dominantEmotion });
                    });
                }
            } else {
                console.warn("No average emotions data found in the API response or result array is empty:", result);
            }

            console.log("Processed Emotion Data for Gradient:", emotionData);
            const gradientStyle = createEmotionGradient(emotionData);
            if (groupEmotionBarElement) {
                groupEmotionBarElement.style.backgroundImage = gradientStyle;
            } else {
                console.error("Group emotion bar element not found after loading emotions!");
            }

        } catch (error) {
            console.error("Error loading project data:", error);
            projectNameElement.textContent = "Error";
            projectDescriptionElement.textContent = "Failed to load project details.";
            memberListElement.innerHTML = "";
            if (groupEmotionBarElement) groupEmotionBarElement.style.display = "none";
        }
    }
    // --- End Data Loading Function ---

    document.addEventListener("astro:page-load", () => {
        chorusAPI
            .isLoggedIn()
            .then((isLoggedIn) => {
                if (!isLoggedIn) {
                    setTimeout(() => {
                        navigate("/login");
                    }, 1000);
                } else {
                    const urlParams = new URLSearchParams(window.location.search);
                    const projectId = urlParams.get("project_id");
                    const timeRangeFromUrl = urlParams.get("time_range");

                    const timeRangeSelect = document.getElementById("time-range") as HTMLSelectElement;
                    const projectNameElement = document.getElementById("project-name");
                    const projectDescriptionElement = document.getElementById("project-description");
                    const memberListElement = document.getElementById("member-list");
                    const groupEmotionBarElement = document.querySelector("#group-emotionbar-container .emotion-gradient-bar");

                    if (timeRangeFromUrl && [...timeRangeSelect.options].some(opt => opt.value === timeRangeFromUrl)) {
                        timeRangeSelect.value = timeRangeFromUrl;
                    } else {
                        const defaultTimeRange = timeRangeSelect.value;
                        if (timeRangeFromUrl !== defaultTimeRange) {
                            const currentUrl = new URL(window.location.href);
                            currentUrl.searchParams.set('time_range', defaultTimeRange);
                            history.replaceState({}, '', currentUrl.toString());
                        }
                    }

                    if (projectId) {
                        loadProjectData(projectId);

                        timeRangeSelect.addEventListener('change', (event) => {
                            const newTimeRange = (event.target as HTMLSelectElement).value;
                            const currentUrl = new URL(window.location.href);
                            currentUrl.searchParams.set('time_range', newTimeRange);
                            history.pushState({}, '', currentUrl.toString());

                            loadProjectData(projectId);
                        });

                    } else {
                        console.error("No project_id found in URL.");
                        projectNameElement.textContent = "Error";
                        projectDescriptionElement.textContent = "Invalid project ID.";
                        memberListElement.innerHTML = "";
                        if (groupEmotionBarElement) groupEmotionBarElement.style.display = "none";
                    }
                }
            })
            .catch((error) => {
                console.error("Error checking login status:", error);
                const projectNameElement = document.getElementById("project-name");
                const projectDescriptionElement = document.getElementById("project-description");
                const memberListElement = document.getElementById("member-list");
                const groupEmotionBarElement = document.querySelector("#group-emotionbar-container .emotion-gradient-bar");

                if (projectNameElement) projectNameElement.textContent = "Error";
                if (projectDescriptionElement) projectDescriptionElement.textContent = "Could not verify login status.";
                if (memberListElement) memberListElement.innerHTML = "";
                if (groupEmotionBarElement) groupEmotionBarElement.style.display = "none";
            });
    });
</script>

<style>
    #project-container {
        padding: 20px;
        font-family: sans-serif;
    }

    #project-name {
        font-size: 24px;
        font-weight: bold;
        margin-bottom: 5px;
    }

    #project-description {
        margin-top: 0;
        margin-bottom: 20px;
        font-size: 16px;
        color: #555;
    }

    #group-emotionbar-container {
        margin-top: 20px;
        margin-bottom: 30px;
    }

    .emotion-gradient-bar {
        width: 100%;
        border: 1px solid #ccc;
        border-radius: 5px;
        background-color: #eee;
        display: block;
    }

    #group-emotionbar-container .emotion-gradient-bar {
        height: 30px;
        margin-bottom: 10px;
    }

    #group-emotionbar-key ul {
        list-style-type: none;
        padding: 0;
        margin: 0;
    }

    #group-emotionbar-key li {
        display: inline-block;
        margin-right: 15px;
        padding: 4px 0;
        font-size: 14px;
        vertical-align: middle;
    }

    #group-emotionbar-key li::before {
        content: "";
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-right: 6px;
        vertical-align: middle;
    }

    :root {
        --color-anger: rgb(239, 83, 80);
        --color-disgust: rgb(102, 187, 106);
        --color-fear: rgb(66, 165, 245);
        --color-happiness: rgb(255, 213, 79);
        --color-sadness: rgb(126, 87, 194);
        --color-surprise: rgb(255, 167, 38);
        --color-neutral: rgb(173, 216, 230);
        --color-nodata: rgb(220, 220, 220);
    }

    #key-anger::before {
        background-color: var(--color-anger);
    }
    #key-disgust::before {
        background-color: var(--color-disgust);
    }
    #key-fear::before {
        background-color: var(--color-fear);
    }
    #key-happiness::before {
        background-color: var(--color-happiness);
    }
    #key-sadness::before {
        background-color: var(--color-sadness);
    }
    #key-surprise::before {
        background-color: var(--color-surprise);
    }
    #key-neutral::before {
        background-color: var(--color-neutral);
    }
    #key-nodata::before {
        background-color: var(--color-nodata);
    }

    h2 {
        margin-top: 20px;
        margin-bottom: 10px;
        font-size: 20px;
    }

    #member-list {
        padding-left: 0;
    }

    #member-list > div,
    #member-list .member-item {
        margin-bottom: 15px;
        display: block;
    }

    #member-list .error-message {
        color: red;
    }
</style>
